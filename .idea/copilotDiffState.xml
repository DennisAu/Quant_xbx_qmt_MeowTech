<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/QMT实盘无限守护_紧急更新.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/QMT实盘无限守护_紧急更新.py" />
              <option name="originalContent" value="&quot;&quot;&quot;实盘无限守护 - QMT和彩虹客户端自动化管理工具&#10;作者： ∞MeowTech @萌新小强 @无限进化 @萌新小王 @大蒜&#10;版本：3.0&#10;&quot;&quot;&quot;&#10;&#10;# ====================================================================&#10;# USER CONFIG - 用户配置区域（集中管理所有可调参数）&#10;# ====================================================================&#10;class Constants:&#10;    &quot;&quot;&quot;系统常量配置 - 集中管理可调参数&quot;&quot;&quot;&#10;    &#10;    # 进程管理&#10;    GRACEFUL_SHUTDOWN_TIMEOUT = 10  # 优雅关闭超时（秒）&#10;    FORCE_KILL_TIMEOUT = 5         # 强制终止超时（秒）&#10;    PROCESS_START_TIMEOUT = 30     # 进程启动超时（秒）&#10;    &#10;    # 网络测试&#10;    NETWORK_TEST_TIMEOUT = 0.1     # 网络延迟测试超时（秒）&#10;    NETWORK_TEST_SAMPLES = 5       # 延迟测试样本数&#10;    MAX_ACCEPTABLE_LATENCY = 1000  # 最大可接受延迟（毫秒）&#10;    &#10;    # 监控配置&#10;    DEFAULT_MONITOR_INTERVAL = 60      # 监控间隔（秒）&#10;    DEFAULT_NOTIFICATION_INTERVAL = 300 # 通知间隔（秒）&#10;    MEMORY_WARNING_THRESHOLD = 1000    # 内存警告阈值（MB）&#10;    CPU_WARNING_THRESHOLD = 80         # CPU警告阈值（%）&#10;    &#10;    # UI配置&#10;    UI_UPDATE_INTERVAL = 1000      # UI更新间隔（毫秒）&#10;    ASYNC_OPERATION_TIMEOUT = 60   # 异步操作超时（秒）&#10;    STATUS_MESSAGE_MAX_LENGTH = 100 # 状态消息最大长度&#10;    &#10;    # 文件路径&#10;    CONFIG_FILENAME = &quot;guardian_config.json&quot;&#10;    LOG_DIR_NAME = &quot;logs&quot;&#10;    CACHE_DIR_NAME = &quot;cache&quot;&#10;    &#10;    # 进程名称&#10;    QMT_PROCESS_NAME = &quot;XtMiniQmt.exe&quot;&#10;    QMT_CLIENT_PROCESS_NAME = &quot;XtItClient.exe&quot;&#10;    &#10;    # 时间格式&#10;    TIME_FORMAT = &quot;%H:%M:%S&quot;&#10;    DATETIME_FORMAT = &quot;%Y-%m-%d %H:%M:%S&quot;&#10;    &#10;    # 飞书通知&#10;    FEISHU_TIMEOUT = 10           # 通知超时（秒）&#10;    FEISHU_RETRY_COUNT = 3        # 重试次数&#10;    FEISHU_RETRY_DELAY = 2        # 重试延迟（秒）&#10;&#10;# ====================================================================&#10;# 内存管理和异步操作辅助类&#10;# ====================================================================&#10;class MemoryManager:&#10;    &quot;&quot;&quot;内存管理器 - 定期清理大对象，防止内存泄漏&quot;&quot;&quot;&#10;    &#10;    def __init__(self):&#10;        self._large_objects = weakref.WeakSet()  # 使用弱引用避免循环引用&#10;        self._last_cleanup = time.time()&#10;        self._cleanup_interval = 300  # 5分钟清理一次&#10;        &#10;    def register_large_object(self, obj):&#10;        &quot;&quot;&quot;注册大对象用于监控&quot;&quot;&quot;&#10;        self._large_objects.add(obj)&#10;        &#10;    def cleanup_if_needed(self):&#10;        &quot;&quot;&quot;根据需要执行内存清理&quot;&quot;&quot;&#10;        current_time = time.time()&#10;        if current_time - self._last_cleanup &gt; self._cleanup_interval:&#10;            self.force_cleanup()&#10;            &#10;    def force_cleanup(self):&#10;        &quot;&quot;&quot;强制执行内存清理&quot;&quot;&quot;&#10;        # 清理大对象缓存&#10;        for obj in list(self._large_objects):&#10;            if hasattr(obj, 'clear_cache'):&#10;                obj.clear_cache()&#10;                &#10;        # 执行垃圾回收&#10;        collected = gc.collect()&#10;        self._last_cleanup = time.time()&#10;        &#10;        if collected &gt; 0:&#10;            log(f&quot;内存清理完成，回收了 {collected} 个对象&quot;)&#10;            &#10;    def get_memory_usage(self):&#10;        &quot;&quot;&quot;获取当前内存使用情况&quot;&quot;&quot;&#10;        process = psutil.Process()&#10;        memory_info = process.memory_info()&#10;        return {&#10;            'rss_mb': memory_info.rss / 1024 / 1024,  # 物理内存&#10;            'vms_mb': memory_info.vms / 1024 / 1024,  # 虚拟内存&#10;            'percent': process.memory_percent()        # 内存使用百分比&#10;        }&#10;&#10;class AsyncOperationManager:&#10;    &quot;&quot;&quot;异步操作管理器 - 防止长时间操作阻塞UI&quot;&quot;&quot;&#10;    &#10;    def __init__(self, max_workers=4):&#10;        self.executor = ThreadPoolExecutor(max_workers=max_workers)&#10;        self._running_operations = {}&#10;        &#10;    def run_async(self, operation_id, func, *args, **kwargs):&#10;        &quot;&quot;&quot;异步执行操作&#10;        &#10;        Args:&#10;            operation_id: 操作唯一标识&#10;            func: 要执行的函数&#10;            *args, **kwargs: 函数参数&#10;            &#10;        Returns:&#10;            Future对象&#10;        &quot;&quot;&quot;&#10;        if operation_id in self._running_operations:&#10;            log(f&quot;操作 {operation_id} 已在运行中，跳过重复执行&quot;)&#10;            return self._running_operations[operation_id]&#10;            &#10;        future = self.executor.submit(func, *args, **kwargs)&#10;        self._running_operations[operation_id] = future&#10;        &#10;        # 操作完成后自动清理&#10;        def cleanup_operation(fut):&#10;            self._running_operations.pop(operation_id, None)&#10;            &#10;        future.add_done_callback(cleanup_operation)&#10;        return future&#10;        &#10;    def is_operation_running(self, operation_id):&#10;        &quot;&quot;&quot;检查操作是否正在运行&quot;&quot;&quot;&#10;        future = self._running_operations.get(operation_id)&#10;        return future is not None and not future.done()&#10;        &#10;    def cancel_operation(self, operation_id):&#10;        &quot;&quot;&quot;取消正在运行的操作&quot;&quot;&quot;&#10;        future = self._running_operations.get(operation_id)&#10;        if future and not future.done():&#10;            future.cancel()&#10;            return True&#10;        return False&#10;        &#10;    def shutdown(self):&#10;        &quot;&quot;&quot;关闭异步操作管理器&quot;&quot;&quot;&#10;        self.executor.shutdown(wait=True)&#10;&#10;def async_operation(operation_id=None):&#10;    &quot;&quot;&quot;异步操作装饰器 - 自动异步执行函数&quot;&quot;&quot;&#10;    def decorator(func):&#10;        @wraps(func)&#10;        def wrapper(self, *args, **kwargs):&#10;            if hasattr(self, 'async_manager'):&#10;                op_id = operation_id or f&quot;{func.__name__}_{id(self)}&quot;&#10;                return self.async_manager.run_async(op_id, func, self, *args, **kwargs)&#10;            else:&#10;                return func(self, *args, **kwargs)&#10;        return wrapper&#10;    return decorator&#10;&#10;# 标准库导入&#10;import os, sys, json, time, threading, subprocess, shutil, socket, gc&#10;import xml.etree.ElementTree as ET&#10;from datetime import datetime&#10;from functools import wraps&#10;import weakref, statistics, winreg&#10;&#10;# 第三方库导入&#10;import psutil, requests, schedule&#10;from concurrent.futures import ThreadPoolExecutor&#10;&#10;# 设置控制台编码为UTF-8，解决中文乱码问题&#10;try:&#10;    # Windows系统设置控制台编码&#10;    if sys.platform.startswith('win'):&#10;        import io&#10;        sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding='utf-8')&#10;        sys.stderr = io.TextIOWrapper(sys.stderr.buffer, encoding='utf-8')&#10;        # 设置控制台代码页为UTF-8&#10;        os.system('chcp 65001 &gt;nul 2&gt;&amp;1')&#10;except Exception as e:&#10;    pass  # 如果设置失败，继续运行&#10;try:&#10;    from PyQt5.QtWidgets import (&#10;        QApplication, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, QFormLayout,&#10;        QLineEdit, QPushButton, QCheckBox, QLabel, QGroupBox, QTabWidget, QMessageBox&#10;    )&#10;    from PyQt5.QtCore import Qt, QTimer, pyqtSignal as Signal&#10;    from PyQt5.QtGui import QIcon, QFont&#10;except ImportError as e:&#10;    print(f&quot;PyQt5导入失败: {e}&quot;)&#10;    print(&quot;请安装PyQt5: pip install PyQt5&quot;)&#10;    &#10;    # PyQt5模拟类（避免导入错误）&#10;    class MockQt:&#10;        AlignLeft = 0x0001&#10;        AlignCenter = 0x0004&#10;    &#10;    class MockSignal:&#10;        def connect(self, func): pass&#10;        def emit(self, *args): pass&#10;    &#10;    def Signal(*args): return MockSignal()&#10;    &#10;    # 批量创建模拟类&#10;    mock_classes = ['QApplication', 'QMainWindow', 'QWidget', 'QVBoxLayout', 'QHBoxLayout', &#10;                   'QFormLayout', 'QLineEdit', 'QPushButton', 'QCheckBox', 'QLabel', &#10;                   'QGroupBox', 'QTabWidget', 'QMessageBox', 'QTimer', 'QIcon', 'QFont']&#10;    &#10;    for cls_name in mock_classes:&#10;        globals()[cls_name] = type(cls_name, (), {&#10;            '__init__': lambda self, *args, **kwargs: None,&#10;            '__getattr__': lambda self, name: lambda *args, **kwargs: None&#10;        })&#10;    &#10;    Qt = MockQt()&#10;    QApplication.exec = lambda self: 0&#10;&#10;# ====================================================================&#10;# 配置管理模块&#10;# ====================================================================&#10;class ConfigManager:&#10;    &quot;&quot;&quot;配置管理器 - 统一管理配置参数，支持JSON文件持久化&quot;&quot;&quot;&#10;    &#10;    DEFAULT_CONFIG = {&#10;        # QMT相关配置&#10;        &quot;qmt_dir&quot;: r&quot;D:\DFZQxtqmt_win64&quot;,&#10;        &quot;qmt_run_time&quot;: &quot;09:28:00&quot;,&#10;        &quot;qmt_only_vip&quot;: True,&#10;        &quot;enable_qmt_shutdown&quot;: False,&#10;        &quot;qmt_shutdown_time&quot;: &quot;&quot;,&#10;        &#10;        # 彩虹客户端配置&#10;        &quot;rainbow_exe_path&quot;: r&quot;D:\quantclass\quantclass.exe&quot;,&#10;        &quot;rainbow_restart_time&quot;: &quot;09:35:00&quot;,&#10;        &quot;enable_rainbow_shutdown&quot;: False,&#10;        &quot;rainbow_shutdown_time&quot;: &quot;&quot;,&#10;        &#10;        # 数据清理配置&#10;        &quot;delete_base_path&quot;: r&quot;E:\DATA_Center\real_trading\rocket\data\系统缓存&quot;,&#10;        &quot;delete_folders&quot;: &quot;早盘数据,早盘择时&quot;,&#10;        &#10;        # 系统配置&#10;        &quot;enable_startup&quot;: True,&#10;        &quot;enable_system_shutdown&quot;: False,&#10;        &quot;system_shutdown_time&quot;: &quot;&quot;,&#10;        &quot;schedule_running&quot;: False,  # 定时任务运行状态&#10;        &#10;        # 实时监控配置&#10;        &quot;monitor_interval&quot;: 10,  # 监控间隔（秒）&#10;        &quot;notification_interval&quot;: 300,  # 通知间隔（秒，5分钟）&#10;        &quot;notification_start_time&quot;: &quot;09:00:00&quot;,  # 通知时间段开始&#10;        &quot;notification_end_time&quot;: &quot;15:30:00&quot;,   # 通知时间段结束&#10;        &#10;        # 飞书通知配置&#10;        &quot;feishu_webhook_url&quot;: &quot;&quot;,  # 飞书机器人Webhook URL&#10;        &quot;enable_feishu_notification&quot;: True,&#10;        &quot;feishu_at_all&quot;: True  # 是否@所有人，默认开启&#10;    }&#10;    &#10;    def __init__(self):&#10;        &quot;&quot;&quot;初始化配置管理器&quot;&quot;&quot;&#10;        self.config_file = os.path.join(os.path.dirname(os.path.dirname(__file__)), &quot;logs&quot;, &quot;guardian_config.json&quot;)&#10;        os.makedirs(os.path.dirname(self.config_file), exist_ok=True)&#10;        self.config = self._load_config()&#10;        log(f&quot;配置管理器已初始化，配置文件: {self.config_file}&quot;)&#10;    &#10;    def _load_config(self):&#10;        &quot;&quot;&quot;加载配置文件，不存在则使用默认配置&quot;&quot;&quot;&#10;        if os.path.exists(self.config_file):&#10;            try:&#10;                with open(self.config_file, 'r', encoding='utf-8') as f:&#10;                    loaded_config = json.load(f)&#10;                config = self.DEFAULT_CONFIG.copy()&#10;                config.update(loaded_config)&#10;                log(f&quot;成功加载配置文件: {self.config_file}&quot;)&#10;                return config&#10;            except Exception as e:&#10;                log(f&quot;加载配置文件失败: {e}，使用默认配置&quot;)&#10;                return self.DEFAULT_CONFIG.copy()&#10;        else:&#10;            log(&quot;配置文件不存在，使用默认配置&quot;)&#10;            return self.DEFAULT_CONFIG.copy()&#10;    &#10;    def save_config(self):&#10;        &quot;&quot;&quot;保存配置到JSON文件&quot;&quot;&quot;&#10;        try:&#10;            with open(self.config_file, 'w', encoding='utf-8') as f:&#10;                json.dump(self.config, f, ensure_ascii=False, indent=4)&#10;            log(f&quot;配置已保存到: {self.config_file}&quot;)&#10;            return True&#10;        except Exception as e:&#10;            log(f&quot;保存配置文件失败: {e}&quot;)&#10;            return False&#10;    &#10;    def get(self, key, default=None):&#10;        &quot;&quot;&quot;获取配置值&quot;&quot;&quot;&#10;        return self.config.get(key, default)&#10;    &#10;    def set(self, key, value):&#10;        &quot;&quot;&quot;设置配置值&quot;&quot;&quot;&#10;        self.config[key] = value&#10;        log(f&quot;配置已更新: {key} = {value}&quot;)&#10;    &#10;    def update(self, new_config):&#10;        &quot;&quot;&quot;批量更新配置&quot;&quot;&quot;&#10;        self.config.update(new_config)&#10;        log(f&quot;批量更新配置: {len(new_config)} 项&quot;)&#10;&#10;# ====================================================================&#10;# 工具函数模块&#10;# ====================================================================&#10;def log(message):&#10;    &quot;&quot;&quot;带时间戳的日志记录&quot;&quot;&quot;&#10;    timestamp = time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;)&#10;    try:&#10;        if isinstance(message, bytes):&#10;            message = message.decode('utf-8', errors='ignore')&#10;        print(f&quot;[{timestamp}] {message}&quot;, flush=True)&#10;    except Exception:&#10;        try:&#10;            safe_message = str(message).encode('ascii', errors='ignore').decode('ascii')&#10;            print(f&quot;[{timestamp}] {safe_message}&quot;, flush=True)&#10;        except:&#10;            print(f&quot;[{timestamp}] [LOG_ERROR]&quot;, flush=True)&#10;&#10;def is_valid_time(time_str):&#10;    &quot;&quot;&quot;验证时间格式，支持空值&quot;&quot;&quot;&#10;    if not time_str or time_str.strip() == &quot;&quot;:&#10;        return True&#10;    try:&#10;        time.strptime(time_str, '%H:%M:%S')&#10;        return True&#10;    except ValueError:&#10;        return False&#10;&#10;class Worker(threading.Thread):&#10;    &quot;&quot;&quot;通用工作线程 - 执行耗时操作&quot;&quot;&quot;&#10;    def __init__(self, func, *args, **kwargs):&#10;        super().__init__(daemon=True)&#10;        self.func = func&#10;        self.args = args&#10;        self.kwargs = kwargs&#10;&#10;    def run(self):&#10;        try:&#10;            self.func(*self.args, **self.kwargs)&#10;        except Exception as e:&#10;            log(f&quot;工作线程执行失败: {e}&quot;)&#10;&#10;# ====================================================================&#10;# 网络测试模块&#10;# ====================================================================&#10;class NetworkTester:&#10;    &quot;&quot;&quot;网络延迟测试工具 - 行情源优选&quot;&quot;&quot;&#10;    &#10;    @staticmethod&#10;    def measure_latency(ip, port, timeout=0.1):&#10;        &quot;&quot;&quot;测量网络延迟（毫秒）&quot;&quot;&quot;&#10;        try:&#10;            start = time.time()&#10;            with socket.create_connection((ip, int(port)), timeout=timeout):&#10;                end = time.time()&#10;                return (end - start) * 1000&#10;        except Exception:&#10;            return float('inf')&#10;    &#10;    @staticmethod&#10;    def median_latency(ip, port, count=10):&#10;        &quot;&quot;&quot;计算中位数延迟&quot;&quot;&quot;&#10;        latencies = []&#10;        for _ in range(count):&#10;            delay = NetworkTester.measure_latency(ip, port)&#10;            if delay != float('inf'):&#10;                latencies.append(delay)&#10;            time.sleep(0.05)&#10;        return statistics.median(latencies) if latencies else float('inf')&#10;&#10;# ====================================================================&#10;# 飞书通知模块&#10;# ====================================================================&#10;class FeishuNotifier:&#10;    &quot;&quot;&quot;飞书通知器 - 发送消息到群聊&quot;&quot;&quot;&#10;    &#10;    def __init__(self, webhook_url, at_all=False):&#10;        self.webhook_url = webhook_url&#10;        self.at_all = at_all&#10;        self.last_notification_time = {}&#10;        &#10;    def send_message(self, title, content, msg_type=&quot;info&quot;):&#10;        &quot;&quot;&quot;发送消息到飞书&quot;&quot;&quot;&#10;        if not self.webhook_url:&#10;            log(&quot;飞书Webhook URL未配置，跳过通知&quot;)&#10;            return False&#10;            &#10;        try:&#10;            timestamp = datetime.now().strftime(&quot;%Y-%m-%d %H:%M:%S&quot;)&#10;            color_map = {&quot;info&quot;: &quot;blue&quot;, &quot;warning&quot;: &quot;orange&quot;, &quot;error&quot;: &quot;red&quot;, &quot;success&quot;: &quot;green&quot;}&#10;            color = color_map.get(msg_type, &quot;blue&quot;)&#10;            message = {&#10;                &quot;msg_type&quot;: &quot;interactive&quot;,&#10;                &quot;card&quot;: {&#10;                    &quot;config&quot;: {&#10;                        &quot;wide_screen_mode&quot;: True&#10;                    },&#10;                    &quot;header&quot;: {&#10;                        &quot;title&quot;: {&#10;                            &quot;tag&quot;: &quot;plain_text&quot;,&#10;                            &quot;content&quot;: f&quot; {title}&quot;&#10;                        },&#10;                        &quot;template&quot;: color&#10;                    },&#10;                    &quot;elements&quot;: [&#10;                        {&#10;                            &quot;tag&quot;: &quot;div&quot;,&#10;                            &quot;text&quot;: {&#10;                                &quot;tag&quot;: &quot;plain_text&quot;,&#10;                                &quot;content&quot;: content&#10;                            }&#10;                        },&#10;                        {&#10;                            &quot;tag&quot;: &quot;div&quot;,&#10;                            &quot;text&quot;: {&#10;                                &quot;tag&quot;: &quot;plain_text&quot;,&#10;                                &quot;content&quot;: f&quot;⏰ 时间: {timestamp}&quot;&#10;                            }&#10;                        }&#10;                    ]&#10;                }&#10;            }&#10;            &#10;            if self.at_all:&#10;                message[&quot;card&quot;][&quot;elements&quot;].append({&#10;                    &quot;tag&quot;: &quot;div&quot;,&#10;                    &quot;text&quot;: {&#10;                        &quot;tag&quot;: &quot;lark_md&quot;,&#10;                        &quot;content&quot;: &quot;&lt;at user_id=\&quot;all\&quot;&gt;所有人&lt;/at&gt;&quot;&#10;                    }&#10;                })&#10;            response = requests.post(&#10;                self.webhook_url,&#10;                json=message,&#10;                timeout=10&#10;            )&#10;            &#10;            if response.status_code == 200:&#10;                result = response.json()&#10;                if result.get(&quot;code&quot;) == 0:&#10;                    log(f&quot;飞书通知发送成功: {title}&quot;)&#10;                    return True&#10;                else:&#10;                    log(f&quot;飞书通知发送失败: {result.get('msg', '未知错误')}&quot;)&#10;                    return False&#10;            else:&#10;                log(f&quot;飞书通知发送失败，HTTP状态码: {response.status_code}&quot;)&#10;                return False&#10;                &#10;        except Exception as e:&#10;            log(f&quot;发送飞书通知异常: {str(e)}&quot;)&#10;            return False&#10;    &#10;    def should_send_notification(self, notification_key, interval_seconds=300):&#10;        &quot;&quot;&quot;检查是否应该发送通知（防频繁通知）&quot;&quot;&quot;&#10;        current_time = time.time()&#10;        last_time = self.last_notification_time.get(notification_key, 0)&#10;        &#10;        if current_time - last_time &gt;= interval_seconds:&#10;            self.last_notification_time[notification_key] = current_time&#10;            return True&#10;        return False&#10;    &#10;    def is_notification_time(self, start_time=&quot;09:00:00&quot;, end_time=&quot;15:30:00&quot;):&#10;        &quot;&quot;&quot;检查当前是否在通知时间段内&quot;&quot;&quot;&#10;        try:&#10;            current_time = datetime.now().time()&#10;            start = datetime.strptime(start_time, &quot;%H:%M:%S&quot;).time()&#10;            end = datetime.strptime(end_time, &quot;%H:%M:%S&quot;).time()&#10;            return start &lt;= current_time &lt;= end&#10;        except:&#10;            return True  # 如果时间格式错误，默认允许通知&#10;&#10;# ====================================================================&#10;# 行情源优选模块（保持原有逻辑不变）&#10;# ====================================================================&#10;class ServerOptimizer:&#10;    &quot;&quot;&quot;行情源服务器优选器 - 自动选择最佳行情和交易服务器&quot;&quot;&quot;&#10;    &#10;    def __init__(self, qmt_dir_path, only_vip=True):&#10;        self.qmt_dir_path = qmt_dir_path&#10;        self.only_vip = only_vip&#10;        self.network_tester = NetworkTester()&#10;    &#10;    def find_best_servers(self):&#10;        &quot;&quot;&quot;查找最佳行情和交易服务器&quot;&quot;&quot;&#10;        log(f&quot;开始查找最佳服务器，QMT路径: {self.qmt_dir_path}&quot;)&#10;        &#10;        # 终止QMT进程&#10;        self._terminate_qmt_processes()&#10;        &#10;        # 解析配置文件&#10;        config_path = fr'{self.qmt_dir_path}\userdata_mini\users\xtquoterconfig.xml'&#10;        if not os.path.exists(config_path):&#10;            log(f&quot;错误: 配置文件不存在 {config_path}&quot;)&#10;            return None, None, None, None, None&#10;        &#10;        try:&#10;            tree = ET.parse(config_path)&#10;            quoter_server_map = tree.find('QuoterServers')&#10;            quoter_server_list = quoter_server_map.findall('QuoterServer')&#10;            &#10;            # 解析服务器信息&#10;            qs_infos = self._parse_server_info(quoter_server_list)&#10;            &#10;            # 测试服务器延迟&#10;            results = self._test_server_latency(qs_infos)&#10;            &#10;            # 选择最佳服务器&#10;            best_hq, best_jy = self._select_best_servers(results)&#10;            &#10;            return best_hq, best_jy, tree, quoter_server_map, config_path&#10;        &#10;        except Exception as e:&#10;            log(f&quot;解析配置文件出错: {str(e)}&quot;)&#10;            return None, None, None, None, None&#10;    &#10;    def _terminate_qmt_processes(self):&#10;        &quot;&quot;&quot;终止QMT进程&quot;&quot;&quot;&#10;        for proc in psutil.process_iter(['pid', 'name', 'exe']):&#10;            try:&#10;                if proc.info['name'] == 'XtMiniQmt.exe':&#10;                    exe_path = (proc.info['exe'] or '').lower()&#10;                    if self.qmt_dir_path.lower() in exe_path:&#10;                        log(f&quot;终止进程: PID={proc.pid}, Path={exe_path}&quot;)&#10;                        proc.kill()&#10;            except (psutil.NoSuchProcess, psutil.AccessDenied):&#10;                continue&#10;    &#10;    def _parse_server_info(self, quoter_server_list):&#10;        &quot;&quot;&quot;解析服务器信息&quot;&quot;&quot;&#10;        qs_infos = {}&#10;        for server in quoter_server_list:&#10;            quoter_type = server.attrib['quotertype']&#10;            if self.only_vip and quoter_type == '0' and 'VIP' not in server.attrib['servername']:&#10;                continue&#10;            info = {&#10;                'ip': server.attrib['address'],&#10;                'port': int(server.attrib['port']),&#10;                'username': server.attrib['username'],&#10;                'pwd': server.attrib['password'],&#10;                'type': quoter_type,&#10;                'servername': server.attrib['servername']&#10;            }&#10;            qs_infos[info['ip']] = info&#10;        return qs_infos&#10;    &#10;    def _test_server_latency(self, qs_infos):&#10;        &quot;&quot;&quot;测试服务器延迟&quot;&quot;&quot;&#10;        results = []&#10;        log(f&quot;开始测试 {len(qs_infos)} 个服务器...&quot;)&#10;        &#10;        for info in qs_infos.values():&#10;            median_value = self.network_tester.median_latency(info['ip'], info['port'])&#10;            info['median_value'] = median_value&#10;            results.append(info)&#10;            &#10;            server_type = &quot;行情&quot; if info['type'] == '0' else &quot;交易&quot;&#10;            log(f'{server_type}-{info[&quot;servername&quot;]} {info[&quot;ip&quot;]} 延迟: {median_value:.2f} ms')&#10;        &#10;        return results&#10;    &#10;    def _select_best_servers(self, results):&#10;        &quot;&quot;&quot;选择最佳服务器&quot;&quot;&quot;&#10;        hq_results = [r for r in results if r['type'] == '0']&#10;        jy_results = [r for r in results if r['type'] == '1']&#10;        &#10;        best_hq = min(hq_results, key=lambda x: x['median_value'], default=None)&#10;        best_jy = min(jy_results, key=lambda x: x['median_value'], default=None)&#10;        &#10;        log(&quot;=&quot; * 80)&#10;        &#10;        if best_hq:&#10;            log(f&quot;最佳行情服务器: {best_hq['servername']} IP={best_hq['ip']} 延迟: {best_hq['median_value']:.2f} ms&quot;)&#10;        else:&#10;            log(&quot;未找到有效的行情服务器&quot;)&#10;        &#10;        if best_jy:&#10;            log(f&quot;最佳交易服务器: {best_jy['servername']} IP={best_jy['ip']} 延迟: {best_jy['median_value']:.2f} ms&quot;)&#10;        else:&#10;            log(&quot;未找到有效的交易服务器&quot;)&#10;        &#10;        return best_hq, best_jy&#10;    &#10;    def update_qmt_config(self, best_hq, best_jy, tree, quoter_server_map, config_path):&#10;        &quot;&quot;&quot;更新QMT配置文件&quot;&quot;&quot;&#10;        if not best_hq or not best_jy or tree is None or quoter_server_map is None:&#10;            log(&quot;更新配置失败: 缺少必要参数&quot;)&#10;            return False&#10;        &#10;        try:&#10;            current_stock = quoter_server_map.get('current_stock')&#10;            current_trade_stock = quoter_server_map.get('current_trade_stock')&#10;            &#10;            if not current_stock or not current_trade_stock:&#10;                log(&quot;更新配置失败: 找不到当前服务器配置&quot;)&#10;                return False&#10;            &#10;            current_stock_list = current_stock.split('_')&#10;            current_stock_list[-2] = best_hq['ip']&#10;            current_stock_list[-1] = str(best_hq['port'])&#10;            &#10;            current_trade_stock_list = current_trade_stock.split('_')&#10;            current_trade_stock_list[-2] = best_jy['ip']&#10;            current_trade_stock_list[-1] = str(best_jy['port'])&#10;            &#10;            quoter_server_map.set('current_stock', '_'.join(current_stock_list))&#10;            quoter_server_map.set('current_trade_stock', '_'.join(current_trade_stock_list))&#10;            &#10;            tree.write(config_path, encoding='utf-8', xml_declaration=True)&#10;            log(f&quot;配置已更新并保存到 {config_path}&quot;)&#10;            return True&#10;        except Exception as e:&#10;            log(f&quot;更新配置文件出错: {str(e)}&quot;)&#10;            return False&#10;&#10;# ====================================================================&#10;# 进程管理模块&#10;# ====================================================================&#10;class ProcessManager:&#10;    &quot;&quot;&quot;进程管理器 - 统一管理进程启动和终止&quot;&quot;&quot;&#10;&#10;    @staticmethod&#10;    def terminate_processes_by_name(process_name, target_path=None, graceful_timeout=10):&#10;        &quot;&quot;&quot;根据进程名终止进程 - 优雅关闭机制&quot;&quot;&quot;&#10;        processes_to_kill = []&#10;&#10;        for proc in psutil.process_iter(['pid', 'name', 'exe', 'status']):&#10;            try:&#10;                if proc.info['name'] == process_name:&#10;                    if target_path is None or (proc.info['exe'] and target_path.lower() in proc.info['exe'].lower()):&#10;                        processes_to_kill.append(proc)&#10;                        log(f&quot;发现目标进程: {process_name} (PID={proc.pid}, 状态={proc.info['status']})&quot;)&#10;            except (psutil.NoSuchProcess, psutil.AccessDenied):&#10;                continue&#10;&#10;        if not processes_to_kill:&#10;            log(f&quot;未发现运行中的 {process_name} 进程&quot;)&#10;            return 0, 0&#10;&#10;        success_count = 0&#10;        failed_count = 0&#10;&#10;        for proc in processes_to_kill:&#10;            try:&#10;                if not proc.is_running():&#10;                    log(f&quot;进程 {proc.pid} 已经不存在，跳过&quot;)&#10;                    continue&#10;&#10;                log(f&quot;开始优雅关闭进程: {process_name} (PID={proc.pid})&quot;)&#10;                proc.terminate()&#10;&#10;                try:&#10;                    proc.wait(timeout=graceful_timeout)&#10;                    log(f&quot;✓ 进程 {proc.pid} 已优雅退出&quot;)&#10;                    success_count += 1&#10;                    continue&#10;                except psutil.TimeoutExpired:&#10;                    log(f&quot;⚠ 进程 {proc.pid} 在 {graceful_timeout}s 内未响应优雅关闭，强制终止&quot;)&#10;&#10;                if proc.is_running():&#10;                    proc.kill()&#10;                    try:&#10;                        proc.wait(timeout=5)&#10;                        log(f&quot;✓ 进程 {proc.pid} 已强制终止&quot;)&#10;                        success_count += 1&#10;                    except psutil.TimeoutExpired:&#10;                        log(f&quot;✗ 进程 {proc.pid} 强制终止失败，可能成为僵尸进程&quot;)&#10;                        failed_count += 1&#10;&#10;            except psutil.NoSuchProcess:&#10;                log(f&quot;✓ 进程 {proc.pid} 已自然退出&quot;)&#10;                success_count += 1&#10;            except psutil.AccessDenied:&#10;                log(f&quot;✗ 权限不足，无法终止进程 {proc.pid}&quot;)&#10;                failed_count += 1&#10;            except Exception as e:&#10;                log(f&quot;✗ 终止进程 {proc.pid} 时发生异常: {e}&quot;)&#10;                failed_count += 1&#10;&#10;        # 第三步：僵尸进程检测和清理&#10;        ProcessManager._cleanup_zombie_processes(process_name)&#10;&#10;        log(f&quot;进程终止完成: 成功 {success_count} 个，失败 {failed_count} 个&quot;)&#10;        return success_count, failed_count&#10;&#10;    @staticmethod&#10;    def _cleanup_zombie_processes(process_name):&#10;        &quot;&quot;&quot;清理僵尸进程 - 检测并报告僵尸进程状态&quot;&quot;&quot;&#10;        zombie_count = 0&#10;&#10;        try:&#10;            for proc in psutil.process_iter(['pid', 'name', 'status']):&#10;                try:&#10;                    if (proc.info['name'] == process_name and&#10;                        proc.info['status'] == psutil.STATUS_ZOMBIE):&#10;                        zombie_count += 1&#10;                        log(f&quot;⚠ 检测到僵尸进程: {process_name} (PID={proc.pid})&quot;)&#10;&#10;                        # 尝试通过父进程清理僵尸进程&#10;                        try:&#10;                            parent = proc.parent()&#10;                            if parent:&#10;                                log(f&quot;僵尸进程的父进程: PID={parent.pid}, 名称={parent.name()}&quot;)&#10;                        except (psutil.NoSuchProcess, psutil.AccessDenied):&#10;                            pass&#10;&#10;                except (psutil.NoSuchProcess, psutil.AccessDenied):&#10;                    continue&#10;        except Exception as e:&#10;            log(f&quot;僵尸进程检测时发生异常: {e}&quot;)&#10;&#10;        if zombie_count &gt; 0:&#10;            log(f&quot;⚠ 发现 {zombie_count} 个 {process_name} 僵尸进程，建议重启系统清理&quot;)&#10;        else:&#10;            log(f&quot;✓ 未发现 {process_name} 僵尸进程&quot;)&#10;&#10;    @staticmethod&#10;    def get_process_status(process_name, target_path=None):&#10;        &quot;&quot;&quot;获取进程状态信息&quot;&quot;&quot;&#10;        processes = []&#10;&#10;        for proc in psutil.process_iter(['pid', 'name', 'exe', 'status', 'create_time', 'memory_info', 'cpu_percent']):&#10;            try:&#10;                if proc.info['name'] == process_name:&#10;                    if target_path is None or (proc.info['exe'] and target_path.lower() in proc.info['exe'].lower()):&#10;                        create_time = proc.info['create_time']&#10;                        running_time = time.time() - create_time&#10;&#10;                        process_info = {&#10;                            'pid': proc.info['pid'],&#10;                            'status': proc.info['status'],&#10;                            'exe_path': proc.info['exe'],&#10;                            'running_time_seconds': running_time,&#10;                            'memory_mb': proc.info['memory_info'].rss / 1024 / 1024 if proc.info['memory_info'] else 0,&#10;                            'cpu_percent': proc.info['cpu_percent'] or 0&#10;                        }&#10;                        processes.append(process_info)&#10;&#10;            except (psutil.NoSuchProcess, psutil.AccessDenied):&#10;                continue&#10;&#10;        return {&#10;            'process_name': process_name,&#10;            'count': len(processes),&#10;            'processes': processes,&#10;            'is_running': len(processes) &gt; 0&#10;        }&#10;&#10;    @staticmethod&#10;    def start_process(exe_path, wait_for_start=True, start_timeout=30):&#10;        &quot;&quot;&quot;启动进程 - 增强版启动机制&quot;&quot;&quot;&#10;        if not os.path.exists(exe_path):&#10;            error_msg = f&quot;可执行文件不存在: {exe_path}&quot;&#10;            log(f&quot;✗ {error_msg}&quot;)&#10;            return False, error_msg&#10;&#10;        try:&#10;            log(f&quot;正在启动进程: {exe_path}&quot;)&#10;&#10;            process = subprocess.Popen([exe_path])&#10;&#10;            if not wait_for_start:&#10;                log(f&quot;✓ 进程已启动 (PID={process.pid})，未等待启动确认&quot;)&#10;                return True, process.pid&#10;&#10;            process_name = os.path.basename(exe_path)&#10;            start_time = time.time()&#10;&#10;            while time.time() - start_time &lt; start_timeout:&#10;                status = ProcessManager.get_process_status(process_name, os.path.dirname(exe_path))&#10;                if status['is_running']:&#10;                    running_process = status['processes'][0]&#10;                    log(f&quot;✓ 进程启动成功: {process_name} (PID={running_process['pid']})&quot;)&#10;                    return True, running_process['pid']&#10;&#10;                time.sleep(1)  # 每秒检查一次&#10;&#10;            # 启动超时&#10;            error_msg = f&quot;进程启动超时 ({start_timeout}s): {process_name}&quot;&#10;            log(f&quot;✗ {error_msg}&quot;)&#10;            return False, error_msg&#10;&#10;        except Exception as e:&#10;            error_msg = f&quot;启动进程时发生异常: {str(e)}&quot;&#10;            log(f&quot;✗ {error_msg}&quot;)&#10;            return False, error_msg&#10;&#10;    @staticmethod&#10;    def monitor_process_health(process_name, target_path=None):&#10;        &quot;&quot;&quot;监控进程健康状态 - 新增健康检查功能&#10;&#10;        Args:&#10;            process_name: 进程名称&#10;            target_path: 目标路径过滤（可选）&#10;&#10;        Returns:&#10;            dict: 健康状态报告&#10;        &quot;&quot;&quot;&#10;        status = ProcessManager.get_process_status(process_name, target_path)&#10;&#10;        health_report = {&#10;            'process_name': process_name,&#10;            'is_healthy': True,&#10;            'issues': [],&#10;            'recommendations': [],&#10;            'status': status&#10;        }&#10;&#10;        if not status['is_running']:&#10;            health_report['is_healthy'] = False&#10;            health_report['issues'].append(&quot;进程未运行&quot;)&#10;            health_report['recommendations'].append(&quot;检查进程是否正常启动&quot;)&#10;            return health_report&#10;&#10;        # 检查多实例问题&#10;        if status['count'] &gt; 1:&#10;            health_report['is_healthy'] = False&#10;            health_report['issues'].append(f&quot;检测到多个实例运行 ({status['count']} 个)&quot;)&#10;            health_report['recommendations'].append(&quot;终止多余的进程实例&quot;)&#10;&#10;        # 检查僵尸进程&#10;        for proc_info in status['processes']:&#10;            if proc_info['status'] == psutil.STATUS_ZOMBIE:&#10;                health_report['is_healthy'] = False&#10;                health_report['issues'].append(f&quot;检测到僵尸进程 (PID={proc_info['pid']})&quot;)&#10;                health_report['recommendations'].append(&quot;重启系统清理僵尸进程&quot;)&#10;&#10;        # 检查内存使用&#10;        for proc_info in status['processes']:&#10;            if proc_info['memory_mb'] &gt; 1000:  # 超过1GB内存&#10;                health_report['issues'].append(f&quot;内存使用较高: {proc_info['memory_mb']:.1f}MB (PID={proc_info['pid']})&quot;)&#10;                health_report['recommendations'].append(&quot;监控内存使用情况，考虑重启进程&quot;)&#10;&#10;        return health_report&#10;&#10;# ====================================================================&#10;# 实时监控模块&#10;# ====================================================================&#10;class MonitoringThread(threading.Thread):&#10;    &quot;&quot;&quot;实时监控线程 - 监控QMT进程和网络状态&quot;&quot;&quot;&#10;&#10;    def __init__(self, config_manager, feishu_notifier, status_callback=None, server_update_callback=None):&#10;        super().__init__(daemon=True)&#10;        self.config_manager = config_manager&#10;        self.feishu_notifier = feishu_notifier&#10;        self.status_callback = status_callback&#10;        self.server_update_callback = server_update_callback&#10;        self.running = False&#10;        self.last_status = {}&#10;        self.server_optimizer = None&#10;&#10;        self.last_qmt_status = False&#10;        self.last_network_status = False&#10;&#10;    def start_monitoring(self):&#10;        &quot;&quot;&quot;启动监控&quot;&quot;&quot;&#10;        self.running = True&#10;        self.start()&#10;        log(&quot;实时监控已启动&quot;)&#10;&#10;    def stop_monitoring(self):&#10;        &quot;&quot;&quot;停止监控&quot;&quot;&quot;&#10;        self.running = False&#10;        log(&quot;实时监控已停止&quot;)&#10;&#10;    def run(self):&#10;        &quot;&quot;&quot;监控主循环&quot;&quot;&quot;&#10;        while self.running:&#10;            try:&#10;                self._check_qmt_status()&#10;                self._check_network_status()&#10;&#10;                interval = self.config_manager.get('monitor_interval', 10)&#10;                time.sleep(interval)&#10;&#10;            except Exception as e:&#10;                log(f&quot;监控线程异常: {str(e)}&quot;)&#10;                time.sleep(10)&#10;&#10;    def _check_qmt_status(self):&#10;        &quot;&quot;&quot;检查QMT进程状态&quot;&quot;&quot;&#10;        qmt_dir = self.config_manager.get('qmt_dir')&#10;        if not qmt_dir:&#10;            return&#10;&#10;        qmt_running = False&#10;        qmt_processes = []&#10;        all_qmt_processes = []  # 记录所有XtMiniQmt.exe进程&#10;&#10;        for proc in psutil.process_iter(['pid', 'name', 'exe']):&#10;            try:&#10;                if proc.info['name'] == 'XtMiniQmt.exe':&#10;                    exe_path = proc.info['exe'] or ''&#10;                    all_qmt_processes.append({&#10;                        'pid': proc.info['pid'],&#10;                        'exe_path': exe_path&#10;                    })&#10;&#10;                    # 路径匹配检查 - 支持多种匹配方式&#10;                    exe_path_lower = exe_path.lower()&#10;                    qmt_dir_lower = qmt_dir.lower()&#10;&#10;                    # 方式1: 直接包含检查&#10;                    path_match_1 = qmt_dir_lower in exe_path_lower&#10;&#10;                    # 方式2: 标准化路径后检查&#10;                    try:&#10;                        exe_path_norm = os.path.normpath(exe_path_lower)&#10;                        qmt_dir_norm = os.path.normpath(qmt_dir_lower)&#10;                        path_match_2 = qmt_dir_norm in exe_path_norm&#10;                    except:&#10;                        path_match_2 = False&#10;&#10;                    # 方式3: 检查是否在QMT目录的bin.x64子目录下&#10;                    expected_exe_path = os.path.join(qmt_dir, 'bin.x64', 'XtMiniQmt.exe').lower()&#10;                    path_match_3 = exe_path_lower == expected_exe_path&#10;&#10;                    if path_match_1 or path_match_2 or path_match_3:&#10;                        qmt_running = True&#10;                        qmt_processes.append(proc.info)&#10;&#10;            except (psutil.NoSuchProcess, psutil.AccessDenied) as e:&#10;                continue&#10;&#10;        # 调试日志 - 仅在状态变化或没有找到匹配进程时输出&#10;        if not qmt_running and all_qmt_processes:&#10;            log(f&quot;[调试] 发现 {len(all_qmt_processes)} 个XtMiniQmt.exe进程，但路径不匹配:&quot;)&#10;            log(f&quot;[调试] 配置的QMT目录: {qmt_dir}&quot;)&#10;            for proc_info in all_qmt_processes:&#10;                log(f&quot;[调试] PID {proc_info['pid']}: {proc_info['exe_path']}&quot;)&#10;&#10;        current_status = {&#10;            'qmt_running': qmt_running,&#10;            'qmt_process_count': len(qmt_processes)&#10;        }&#10;&#10;        if self.last_status.get('qmt_running') != qmt_running:&#10;            self._send_qmt_status_notification(qmt_running, qmt_processes)&#10;&#10;        self.last_status.update(current_status)&#10;        # 更新QMT状态标志，用于界面显示&#10;        self.last_qmt_status = qmt_running&#10;&#10;        if self.status_callback:&#10;            status_msg = f&quot;QMT状态: {'运行中' if qmt_running else '未运行'} ({len(qmt_processes)}个进程)&quot;&#10;            self.status_callback(status_msg)&#10;&#10;    def _check_network_status(self):&#10;        &quot;&quot;&quot;检查网络连接状态&quot;&quot;&quot;&#10;        qmt_dir = self.config_manager.get('qmt_dir')&#10;        if not qmt_dir:&#10;            return&#10;&#10;        try:&#10;            if not self.server_optimizer:&#10;                only_vip = self.config_manager.get('qmt_only_vip', True)&#10;                self.server_optimizer = ServerOptimizer(qmt_dir, only_vip)&#10;&#10;            current_servers = self._get_current_server_config()&#10;            if not current_servers:&#10;                return&#10;&#10;            hq_server = current_servers.get('hq_server')&#10;            jy_server = current_servers.get('jy_server')&#10;&#10;            network_status = {&#10;                'hq_server': hq_server,&#10;                'jy_server': jy_server,&#10;                'hq_latency': float('inf'),&#10;                'jy_latency': float('inf'),&#10;                'last_test_time': datetime.now().strftime('%H:%M:%S')&#10;            }&#10;&#10;            if hq_server:&#10;                network_status['hq_latency'] = NetworkTester.measure_latency(&#10;                    hq_server['ip'], hq_server['port']&#10;                )&#10;&#10;            if jy_server:&#10;                network_status['jy_latency'] = NetworkTester.measure_latency(&#10;                    jy_server['ip'], jy_server['port']&#10;                )&#10;&#10;            # 判断网络连接状态&#10;            hq_connected = network_status['hq_latency'] != float('inf') if hq_server else True&#10;            jy_connected = network_status['jy_latency'] != float('inf') if jy_server else True&#10;            network_status['connected'] = hq_connected and jy_connected&#10;&#10;            # 更新网络状态标志，用于界面显示&#10;            self.last_network_status = network_status['connected']&#10;&#10;            self._check_network_status_change(network_status)&#10;&#10;            if self.status_callback:&#10;                status_msg = f&quot;网络状态: {'正常' if network_status.get('connected', False) else '异常'}&quot;&#10;                self.status_callback(status_msg)&#10;&#10;        except Exception as e:&#10;            log(f&quot;网络状态检查异常: {str(e)}&quot;)&#10;&#10;    def _get_current_server_config(self):&#10;        &quot;&quot;&quot;获取当前服务器配置&quot;&quot;&quot;&#10;        try:&#10;            qmt_dir = self.config_manager.get('qmt_dir')&#10;            config_path = os.path.join(qmt_dir, 'userdata_mini', 'users', 'xtquoterconfig.xml')&#10;&#10;            if not os.path.exists(config_path):&#10;                return None&#10;&#10;            tree = ET.parse(config_path)&#10;            quoter_server_map = tree.find('QuoterServers')&#10;            quoter_server_list = quoter_server_map.findall('QuoterServer')&#10;&#10;            hq_server = None&#10;            jy_server = None&#10;&#10;            for server in quoter_server_list:&#10;                server_info = {&#10;                    'ip': server.attrib['address'],&#10;                    'port': int(server.attrib['port']),&#10;                    'servername': server.attrib['servername'],&#10;                    'type': server.attrib['quotertype']&#10;                }&#10;&#10;                if server.attrib['quotertype'] == '0':  # 行情服务器&#10;                    hq_server = server_info&#10;                elif server.attrib['quotertype'] == '1':  # 交易服务器&#10;                    jy_server = server_info&#10;&#10;            return {&#10;                'hq_server': hq_server,&#10;                'jy_server': jy_server&#10;            }&#10;&#10;        except Exception as e:&#10;            log(f&quot;获取服务器配置异常: {str(e)}&quot;)&#10;            return None&#10;&#10;    def _check_network_status_change(self, network_status):&#10;        &quot;&quot;&quot;检查网络状态变化并发送通知&quot;&quot;&quot;&#10;        hq_latency = network_status.get('hq_latency', float('inf'))&#10;        jy_latency = network_status.get('jy_latency', float('inf'))&#10;&#10;        high_latency_threshold = 200&#10;&#10;        if hq_latency &gt; high_latency_threshold:&#10;            self._send_network_notification(&#10;                &quot;行情服务器延迟过高&quot;,&#10;                f&quot;当前延迟: {hq_latency:.2f}ms，建议切换服务器&quot;,&#10;                &quot;warning&quot;&#10;            )&#10;&#10;        if jy_latency &gt; high_latency_threshold:&#10;            self._send_network_notification(&#10;                &quot;交易服务器延迟过高&quot;,&#10;                f&quot;当前延迟: {jy_latency:.2f}ms，建议切换服务器&quot;,&#10;                &quot;warning&quot;&#10;            )&#10;&#10;    def _send_qmt_status_notification(self, is_running, processes):&#10;        &quot;&quot;&quot;发送QMT状态通知&quot;&quot;&quot;&#10;        if not self._should_send_notification('qmt_status'):&#10;            return&#10;&#10;        if is_running:&#10;            title = &quot;QMT启动通知&quot;&#10;            content = f&quot;QMT已启动，当前运行 {len(processes)} 个进程&quot;&#10;            msg_type = &quot;success&quot;&#10;        else:&#10;            title = &quot;QMT关闭通知&quot;&#10;            content = &quot;QMT已关闭或异常退出&quot;&#10;            msg_type = &quot;warning&quot;&#10;&#10;        self.feishu_notifier.send_message(title, content, msg_type)&#10;&#10;    def _send_network_notification(self, title, content, msg_type=&quot;info&quot;):&#10;        &quot;&quot;&quot;发送网络状态通知&quot;&quot;&quot;&#10;        if not self._should_send_notification('network_status'):&#10;            return&#10;&#10;        self.feishu_notifier.send_message(title, content, msg_type)&#10;&#10;    def _should_send_notification(self, notification_type):&#10;        &quot;&quot;&quot;检查是否应该发送通知&quot;&quot;&quot;&#10;        if not self.config_manager.get('enable_feishu_notification', True):&#10;            return False&#10;&#10;        start_time = self.config_manager.get('notification_start_time', '09:00:00')&#10;        end_time = self.config_manager.get('notification_end_time', '15:30:00')&#10;&#10;        if not self.feishu_notifier.is_notification_time(start_time, end_time):&#10;            return False&#10;&#10;        interval = self.config_manager.get('notification_interval', 300)&#10;        return self.feishu_notifier.should_send_notification(notification_type, interval)&#10;&#10;# ====================================================================&#10;# 数据管理模块&#10;# ====================================================================&#10;class DataManager:&#10;    &quot;&quot;&quot;数据管理器 - 早盘数据清理&quot;&quot;&quot;&#10;&#10;    def __init__(self, base_path, folder_names):&#10;        self.base_path = base_path&#10;        self.folder_names = [name.strip() for name in folder_names.split(',')]&#10;&#10;    def delete_early_market_data(self):&#10;        &quot;&quot;&quot;删除早盘数据&quot;&quot;&quot;&#10;        log(&quot;开始删除早盘数据...&quot;)&#10;        deleted_folders = []&#10;        failed_folders = []&#10;&#10;        # ========== ！这两个文件夹不能删除！ 原作者没搞清楚客户端的用作机制，胡乱删除，导致定风波早盘不工作 ===========&#10;        # ========== ！这两个文件夹不能删除！ 原作者没搞清楚客户端的用作机制，胡乱删除，导致定风波早盘不工作 ===========&#10;        # ========== ！这两个文件夹不能删除！ 原作者没搞清楚客户端的用作机制，胡乱删除，导致定风波早盘不工作 ===========&#10;&#10;        # for folder_name in self.folder_names:&#10;        #     folder_path = os.path.join(self.base_path, folder_name)&#10;        #     if os.path.exists(folder_path) and os.path.isdir(folder_path):&#10;        #         try:&#10;        #             shutil.rmtree(folder_path)&#10;        #             deleted_folders.append(folder_name)&#10;        #             log(f&quot;成功删除文件夹: {folder_path}&quot;)&#10;        #         except Exception as e:&#10;        #             failed_folders.append((folder_name, str(e)))&#10;        #             log(f&quot;删除文件夹 {folder_path} 时出错: {e}&quot;)&#10;        #     else:&#10;        #         log(f&quot;文件夹 {folder_path} 不存在，跳过删除&quot;)&#10;&#10;        return deleted_folders, failed_folders&#10;&#10;# ====================================================================&#10;# 开机启动管理模块&#10;# ====================================================================&#10;class StartupManager:&#10;    &quot;&quot;&quot;开机启动管理器 - 健壮实现&quot;&quot;&quot;&#10;&#10;    APP_NAME = &quot;QMT彩虹客户端工具&quot;&#10;    KEY_PATH = r&quot;Software\Microsoft\Windows\CurrentVersion\Run&quot;&#10;&#10;    @classmethod&#10;    def _get_startup_command(cls):&#10;        &quot;&quot;&quot;构建启动命令 - 使用多重验证确保路径正确&quot;&quot;&quot;&#10;        # 获取当前脚本的绝对路径&#10;        script_path = os.path.abspath(__file__)&#10;&#10;        # 获取Python解释器路径&#10;        python_exe = sys.executable&#10;&#10;        # 验证路径存在性&#10;        if not os.path.exists(script_path):&#10;            raise FileNotFoundError(f&quot;脚本文件不存在: {script_path}&quot;)&#10;        if not os.path.exists(python_exe):&#10;            raise FileNotFoundError(f&quot;Python解释器不存在: {python_exe}&quot;)&#10;&#10;        # 构建启动命令&#10;        startup_command = f'&quot;{python_exe}&quot; &quot;{script_path}&quot;'&#10;&#10;        return startup_command, script_path&#10;&#10;    @classmethod&#10;    def set_startup(cls, enable):&#10;        &quot;&quot;&quot;设置开机启动 - 增强版实现&quot;&quot;&quot;&#10;        try:&#10;            if enable:&#10;                # 构建启动命令&#10;                startup_command, script_path = cls._get_startup_command()&#10;&#10;                # 设置注册表项&#10;                with winreg.OpenKey(winreg.HKEY_CURRENT_USER, cls.KEY_PATH, 0, winreg.KEY_SET_VALUE) as key:&#10;                    winreg.SetValueEx(key, cls.APP_NAME, 0, winreg.REG_SZ, startup_command)&#10;&#10;                # 立即验证设置结果&#10;                if cls._verify_startup_setting(startup_command):&#10;                    log(f&quot;✓ 开机启动设置成功&quot;)&#10;                    return True&#10;                else:&#10;                    log(f&quot;✗ 开机启动验证失败&quot;)&#10;                    return False&#10;            else:&#10;                # 取消开机启动&#10;                return cls._remove_startup()&#10;&#10;        except Exception as e:&#10;            log(f&quot;[开机启动] ✗ 设置失败: {e}&quot;)&#10;            return False&#10;&#10;    @classmethod&#10;    def _verify_startup_setting(cls, expected_command):&#10;        &quot;&quot;&quot;验证开机启动设置是否成功&quot;&quot;&quot;&#10;        try:&#10;            with winreg.OpenKey(winreg.HKEY_CURRENT_USER, cls.KEY_PATH, 0, winreg.KEY_READ) as key:&#10;                actual_value, _ = winreg.QueryValueEx(key, cls.APP_NAME)&#10;                return actual_value == expected_command&#10;        except Exception as e:&#10;            log(f&quot;验证失败: {e}&quot;)&#10;            return False&#10;&#10;    @classmethod&#10;    def _remove_startup(cls):&#10;        &quot;&quot;&quot;移除开机启动项&quot;&quot;&quot;&#10;        try:&#10;            # 先检查是否存在&#10;            with winreg.OpenKey(winreg.HKEY_CURRENT_USER, cls.KEY_PATH, 0, winreg.KEY_READ) as key:&#10;                try:&#10;                    winreg.QueryValueEx(key, cls.APP_NAME)&#10;                    # 存在则删除&#10;                    with winreg.OpenKey(winreg.HKEY_CURRENT_USER, cls.KEY_PATH, 0, winreg.KEY_SET_VALUE) as write_key:&#10;                        winreg.DeleteValue(write_key, cls.APP_NAME)&#10;                    log(f&quot;✓ 开机启动已取消&quot;)&#10;                except FileNotFoundError:&#10;                    log(f&quot;✓ 开机启动项不存在&quot;)&#10;            return True&#10;        except Exception as e:&#10;            log(f&quot;✗ 取消开机启动失败: {e}&quot;)&#10;            return False&#10;&#10;    @classmethod&#10;    def check_startup_status(cls):&#10;        &quot;&quot;&quot;检查开机启动状态 - 增强版实现&quot;&quot;&quot;&#10;        try:&#10;            with winreg.OpenKey(winreg.HKEY_CURRENT_USER, cls.KEY_PATH, 0, winreg.KEY_READ) as key:&#10;                registry_value, _ = winreg.QueryValueEx(key, cls.APP_NAME)&#10;&#10;                # 获取当前应该的启动命令&#10;                try:&#10;                    expected_command, script_path = cls._get_startup_command()&#10;&#10;                    # 检查注册表值是否包含正确的脚本路径&#10;                    is_valid = (registry_value == expected_command or&#10;                               (script_path in registry_value and sys.executable in registry_value))&#10;&#10;                    return is_valid&#10;&#10;                except Exception as e:&#10;                    log(f&quot;构建期望命令失败: {e}&quot;)&#10;                    # 如果无法构建期望命令，至少检查注册表项是否存在&#10;                    return bool(registry_value)&#10;&#10;        except FileNotFoundError:&#10;            return False&#10;        except Exception as e:&#10;            log(f&quot;状态检查失败: {e}&quot;)&#10;            return False&#10;&#10;    @classmethod&#10;    def diagnose_startup(cls):&#10;        &quot;&quot;&quot;诊断开机启动问题&quot;&quot;&quot;&#10;        try:&#10;            # 1. 检查脚本和Python路径&#10;            startup_command, script_path = cls._get_startup_command()&#10;        except Exception as e:&#10;            log(f&quot;✗ 路径检查失败: {e}&quot;)&#10;            return False&#10;&#10;        # 2. 检查注册表访问权限&#10;        try:&#10;            with winreg.OpenKey(winreg.HKEY_CURRENT_USER, cls.KEY_PATH, 0, winreg.KEY_READ) as key:&#10;                pass&#10;        except Exception as e:&#10;            log(f&quot;✗ 注册表读取权限异常: {e}&quot;)&#10;            return False&#10;&#10;        # 3. 检查注册表写入权限&#10;        try:&#10;            test_key = f&quot;{cls.APP_NAME}_TEST&quot;&#10;            with winreg.OpenKey(winreg.HKEY_CURRENT_USER, cls.KEY_PATH, 0, winreg.KEY_SET_VALUE) as key:&#10;                winreg.SetValueEx(key, test_key, 0, winreg.REG_SZ, &quot;test&quot;)&#10;                winreg.DeleteValue(key, test_key)&#10;        except Exception as e:&#10;            log(f&quot;✗ 注册表写入权限异常: {e}&quot;)&#10;            return False&#10;&#10;        # 4. 检查当前状态&#10;        current_status = cls.check_startup_status()&#10;        log(f&quot;当前状态: {'已启用' if current_status else '未启用'}&quot;)&#10;&#10;        return True&#10;&#10;# ====================================================================&#10;# 定时任务管理模块&#10;# ====================================================================&#10;class ScheduleManager:&#10;    &quot;&quot;&quot;定时任务管理器&quot;&quot;&quot;&#10;&#10;    def __init__(self, config_manager, status_callback, server_update_callback=None):&#10;        self.config = config_manager&#10;        self.status_callback = status_callback&#10;        self.server_update_callback = server_update_callback&#10;        self.is_running = False&#10;        self.schedule_thread = None&#10;        self.process_manager = ProcessManager()&#10;        self.startup_manager = StartupManager()&#10;&#10;    def start_schedule(self):&#10;        &quot;&quot;&quot;启动定时任务&quot;&quot;&quot;&#10;        if self.is_running:&#10;            return&#10;&#10;        schedule.clear()&#10;&#10;        qmt_time = self.config.get('qmt_run_time')&#10;        if qmt_time and is_valid_time(qmt_time):&#10;            schedule.every().day.at(qmt_time).do(self._scheduled_qmt_restart)&#10;&#10;        rainbow_time = self.config.get('rainbow_restart_time')&#10;        if rainbow_time and is_valid_time(rainbow_time):&#10;            schedule.every().day.at(rainbow_time).do(self._scheduled_rainbow_restart)&#10;&#10;        qmt_shutdown_time = self.config.get('qmt_shutdown_time')&#10;        if qmt_shutdown_time and is_valid_time(qmt_shutdown_time):&#10;            schedule.every().day.at(qmt_shutdown_time).do(self._scheduled_qmt_shutdown)&#10;&#10;        rainbow_shutdown_time = self.config.get('rainbow_shutdown_time')&#10;        if rainbow_shutdown_time and is_valid_time(rainbow_shutdown_time):&#10;            schedule.every().day.at(rainbow_shutdown_time).do(self._scheduled_rainbow_shutdown)&#10;&#10;        system_shutdown_time = self.config.get('system_shutdown_time')&#10;        if system_shutdown_time and is_valid_time(system_shutdown_time):&#10;            schedule.every().day.at(system_shutdown_time).do(self._scheduled_system_shutdown)&#10;&#10;        self.is_running = True&#10;        self.schedule_thread = threading.Thread(target=self._run_schedule, daemon=True)&#10;        self.schedule_thread.start()&#10;        log(&quot;定时任务已启动&quot;)&#10;        self.status_callback(&quot;定时任务已启动&quot;)&#10;&#10;    def stop_schedule(self):&#10;        &quot;&quot;&quot;停止定时任务&quot;&quot;&quot;&#10;        if not self.is_running:&#10;            return&#10;&#10;        schedule.clear()&#10;        self.is_running = False&#10;&#10;        if self.schedule_thread and self.schedule_thread.is_alive():&#10;            self.schedule_thread.join(timeout=2)&#10;&#10;        log(&quot;定时任务已停止&quot;)&#10;        self.status_callback(&quot;定时任务已停止&quot;)&#10;&#10;    # 公共接口方法 - 避免直接访问protected成员&#10;    def restart_qmt_service(self):&#10;        &quot;&quot;&quot;公共接口：重启QMT服务&quot;&quot;&quot;&#10;        return self._restart_qmt()&#10;&#10;    def shutdown_qmt_service(self):&#10;        &quot;&quot;&quot;公共接口：关闭QMT服务&quot;&quot;&quot;&#10;        return self._shutdown_qmt()&#10;&#10;    def restart_rainbow_service(self):&#10;        &quot;&quot;&quot;公共接口：重启彩虹客户端&quot;&quot;&quot;&#10;        return self._restart_rainbow_client()&#10;&#10;    def shutdown_rainbow_service(self):&#10;        &quot;&quot;&quot;公共接口：关闭彩虹客户端&quot;&quot;&quot;&#10;        return self._shutdown_rainbow()&#10;&#10;    def delete_data_files_service(self):&#10;        &quot;&quot;&quot;公共接口：仅删除数据文件&quot;&quot;&quot;&#10;        return self._delete_early_market_data()&#10;&#10;    def restart_rainbow_service_only(self):&#10;        &quot;&quot;&quot;公共接口：仅重启彩虹客户端（不删除数据）&quot;&quot;&quot;&#10;        return self._restart_rainbow_client_only()&#10;&#10;    def shutdown_system_service(self):&#10;        &quot;&quot;&quot;公共接口：关闭系统&quot;&quot;&quot;&#10;        return self._shutdown_system()&#10;&#10;    def _run_schedule(self):&#10;        &quot;&quot;&quot;定时任务运行循环&quot;&quot;&quot;&#10;        while self.is_running:&#10;            schedule.run_pending()&#10;            time.sleep(1)&#10;&#10;    def _scheduled_qmt_restart(self):&#10;        log(f&quot;定时任务触发: QMT重启 ({self.config.get('qmt_run_time')})&quot;)&#10;        self._restart_qmt()&#10;&#10;    def _scheduled_rainbow_restart(self):&#10;        log(f&quot;定时任务触发: 彩虹客户端重启 ({self.config.get('rainbow_restart_time')})&quot;)&#10;        self._restart_rainbow_client()&#10;&#10;    def _scheduled_qmt_shutdown(self):&#10;        log(f&quot;定时任务触发: QMT关闭 ({self.config.get('qmt_shutdown_time')})&quot;)&#10;        self._shutdown_qmt()&#10;&#10;    def _scheduled_rainbow_shutdown(self):&#10;        log(f&quot;定时任务触发: 彩虹客户端关闭 ({self.config.get('rainbow_shutdown_time')})&quot;)&#10;        self._shutdown_rainbow()&#10;&#10;    def _scheduled_system_shutdown(self):&#10;        log(f&quot;定时任务触发: 系统关机 ({self.config.get('system_shutdown_time')})&quot;)&#10;        self._shutdown_system()&#10;&#10;    @async_operation(&quot;qmt_restart&quot;)&#10;    def _restart_qmt(self):&#10;        &quot;&quot;&quot;重启QMT（包含行情源优选）&quot;&quot;&quot;&#10;        try:&#10;            result = self._execute_process_operation(&#10;                operation_name=&quot;重启QMT&quot;,&#10;                process_name=Constants.QMT_PROCESS_NAME,&#10;                exe_path=os.path.join(self.config.get('qmt_dir'), 'bin.x64', 'XtItClient.exe'),&#10;                pre_operation=self._optimize_servers,&#10;                operation_type=&quot;restart&quot;&#10;            )&#10;&#10;            if hasattr(self, 'memory_manager'):&#10;                self.memory_manager.cleanup_if_needed()&#10;&#10;            return result&#10;        except Exception as e:&#10;            log(f&quot;QMT重启过程中发生错误: {e}&quot;)&#10;            return False&#10;&#10;    @async_operation(&quot;rainbow_restart&quot;)&#10;    def _restart_rainbow_client(self):&#10;        &quot;&quot;&quot;重启彩虹客户端（包含删除数据）&quot;&quot;&quot;&#10;        try:&#10;            exe_path = self.config.get('rainbow_exe_path')&#10;            exe_name = os.path.basename(exe_path)&#10;&#10;            result = self._execute_process_operation(&#10;                operation_name=&quot;重启彩虹客户端&quot;,&#10;                process_name=exe_name,&#10;                exe_path=exe_path,&#10;                pre_operation=self._delete_early_market_data,&#10;                operation_type=&quot;restart&quot;&#10;            )&#10;&#10;            if hasattr(self, 'memory_manager'):&#10;                self.memory_manager.cleanup_if_needed()&#10;&#10;            return result&#10;        except Exception as e:&#10;            log(f&quot;彩虹客户端重启过程中发生错误: {e}&quot;)&#10;            return False&#10;&#10;    @async_operation(&quot;rainbow_restart_only&quot;)&#10;    def _restart_rainbow_client_only(self):&#10;        &quot;&quot;&quot;仅重启彩虹客户端（不删除数据）&quot;&quot;&quot;&#10;        try:&#10;            exe_path = self.config.get('rainbow_exe_path')&#10;            exe_name = os.path.basename(exe_path)&#10;&#10;            result = self._execute_process_operation(&#10;                operation_name=&quot;重启彩虹客户端&quot;,&#10;                process_name=exe_name,&#10;                exe_path=exe_path,&#10;                operation_type=&quot;restart&quot;&#10;            )&#10;&#10;            if hasattr(self, 'memory_manager'):&#10;                self.memory_manager.cleanup_if_needed()&#10;&#10;            return result&#10;        except Exception as e:&#10;            log(f&quot;彩虹客户端重启过程中发生错误: {e}&quot;)&#10;            return False&#10;&#10;    @async_operation(&quot;data_cleanup&quot;)&#10;    def _delete_early_market_data(self):&#10;        &quot;&quot;&quot;删除早盘数据&quot;&quot;&quot;&#10;        try:&#10;            self.status_callback(&quot;正在删除早盘数据...&quot;)&#10;&#10;            data_manager = DataManager(&#10;                self.config.get('delete_base_path'),&#10;                self.config.get('delete_folders')&#10;            )&#10;&#10;            # 注册大对象到内存管理器&#10;            if hasattr(self, 'memory_manager'):&#10;                self.memory_manager.register_large_object(data_manager)&#10;&#10;            deleted_folders, failed_folders = data_manager.delete_early_market_data()&#10;&#10;            if not failed_folders:&#10;                self.status_callback(&quot;早盘数据删除成功！&quot;)&#10;            else:&#10;                self.status_callback(f&quot;部分数据删除失败: {failed_folders}&quot;)&#10;&#10;        except Exception as e:&#10;            log(f&quot;数据删除过程中发生错误: {e}&quot;)&#10;            self.status_callback(f&quot;数据删除失败: {e}&quot;)&#10;        finally:&#10;            # 执行内存清理&#10;            if hasattr(self, 'memory_manager'):&#10;                self.memory_manager.cleanup_if_needed()&#10;&#10;    def _shutdown_qmt(self):&#10;        &quot;&quot;&quot;关闭QMT - 优化版&quot;&quot;&quot;&#10;        return self._execute_process_operation(&#10;            operation_name=&quot;关闭QMT&quot;,&#10;            process_name=Constants.QMT_PROCESS_NAME,&#10;            operation_type=&quot;shutdown&quot;&#10;        )&#10;&#10;    def _shutdown_rainbow(self):&#10;        &quot;&quot;&quot;关闭彩虹客户端 - 优化版&quot;&quot;&quot;&#10;        exe_path = self.config.get('rainbow_exe_path')&#10;        exe_name = os.path.basename(exe_path)&#10;&#10;        return self._execute_process_operation(&#10;            operation_name=&quot;关闭彩虹客户端&quot;,&#10;            process_name=exe_name,&#10;            operation_type=&quot;shutdown&quot;&#10;        )&#10;&#10;    def _execute_process_operation(self, operation_name, process_name, exe_path=None,&#10;                                 pre_operation=None, operation_type=&quot;restart&quot;):&#10;        &quot;&quot;&quot;通用进程操作方法&quot;&quot;&quot;&#10;        log(f&quot;开始执行{operation_name}任务...&quot;)&#10;        self.status_callback(f&quot;正在{operation_name}...&quot;)&#10;&#10;        try:&#10;            if pre_operation and callable(pre_operation):&#10;                pre_operation()&#10;&#10;            if operation_type in [&quot;restart&quot;, &quot;shutdown&quot;]:&#10;                self.status_callback(f&quot;正在关闭{process_name}进程...&quot;)&#10;                success_count, failed_count = self.process_manager.terminate_processes_by_name(process_name)&#10;                self._report_process_status(operation_name, success_count, failed_count, &quot;关闭&quot;)&#10;&#10;            if operation_type in [&quot;restart&quot;, &quot;start&quot;] and exe_path:&#10;                self.status_callback(f&quot;正在启动{operation_name.replace('重启', '').replace('关闭', '')}...&quot;)&#10;                success, result = self.process_manager.start_process(exe_path)&#10;&#10;                if success:&#10;                    self.status_callback(f&quot;✓ {operation_name}成功！(PID={result})&quot;)&#10;                    return True&#10;                else:&#10;                    self.status_callback(f&quot;✗ {operation_name}失败: {result}&quot;)&#10;                    return False&#10;&#10;            if operation_type == &quot;shutdown&quot;:&#10;                return True&#10;&#10;        except Exception as e:&#10;            log(f&quot;{operation_name}失败: {e}&quot;)&#10;            self.status_callback(f&quot;✗ {operation_name}失败: {e}&quot;)&#10;            return False&#10;&#10;    def _report_process_status(self, operation_name, success_count, failed_count, action=&quot;操作&quot;):&#10;        if failed_count &gt; 0:&#10;            self.status_callback(f&quot;⚠ {operation_name}{action}部分失败 (成功:{success_count}, 失败:{failed_count})&quot;)&#10;        elif success_count &gt; 0:&#10;            self.status_callback(f&quot;✓ {operation_name}{action}成功 ({success_count} 个进程)&quot;)&#10;        else:&#10;            self.status_callback(f&quot;ℹ 未发现运行中的进程&quot;)&#10;&#10;    def _shutdown_system(self):&#10;        &quot;&quot;&quot;系统关机&quot;&quot;&quot;&#10;        log(&quot;系统将在1分钟后关机...&quot;)&#10;        self.status_callback(&quot;系统将在1分钟后关机...&quot;)&#10;        os.system(&quot;shutdown -s -t 60&quot;)&#10;&#10;    @async_operation(&quot;server_optimization&quot;)&#10;    def _optimize_servers(self):&#10;        &quot;&quot;&quot;执行行情源优选&quot;&quot;&quot;&#10;        log(&quot;开始执行行情源自动切换任务...&quot;)&#10;        self.status_callback(&quot;正在优选行情源...&quot;)&#10;&#10;        try:&#10;            optimizer = ServerOptimizer(&#10;                self.config.get('qmt_dir'),&#10;                self.config.get('qmt_only_vip', True)&#10;            )&#10;&#10;            # 注册大对象到内存管理器&#10;            if hasattr(self, 'memory_manager'):&#10;                self.memory_manager.register_large_object(optimizer)&#10;&#10;            best_hq, best_jy, tree, quoter_server_map, config_path = optimizer.find_best_servers()&#10;&#10;            # 初始化变量避免未定义错误&#10;            hq_info = &quot;未知服务器&quot;&#10;            jy_info = &quot;未知服务器&quot;&#10;&#10;            if best_hq and best_jy:&#10;                if optimizer.update_qmt_config(best_hq, best_jy, tree, quoter_server_map, config_path):&#10;                    log(&quot;✅ 行情源自动切换任务执行完成&quot;)&#10;                    hq_info = f&quot;{best_hq['servername']} ({best_hq['median_value']:.2f}ms)&quot;&#10;                    jy_info = f&quot;{best_jy['servername']} ({best_jy['median_value']:.2f}ms)&quot;&#10;                    log(f&quot;最佳行情服务器: {hq_info}&quot;)&#10;                    log(f&quot;最佳交易服务器: {jy_info}&quot;)&#10;&#10;                    self.status_callback(&quot;行情源优选完成&quot;)&#10;                    # 更新UI显示的服务器信息&#10;                    if self.server_update_callback:&#10;                        self.server_update_callback(hq_info, jy_info)&#10;                else:&#10;                    log(&quot;❌ 配置更新失败，将使用默认配置启动QMT&quot;)&#10;                    self.status_callback(&quot;行情源配置更新失败，将使用默认配置启动QMT&quot;)&#10;                    # 更新UI显示失败状态&#10;                    if self.server_update_callback:&#10;                        self.server_update_callback(&quot;配置更新失败&quot;, &quot;配置更新失败&quot;)&#10;            else:&#10;                log(&quot;❌ 未找到有效的服务器，将使用默认配置启动QMT&quot;)&#10;                self.status_callback(&quot;未找到有效的行情服务器，将使用默认配置启动QMT&quot;)&#10;                # 更新UI显示未找到服务器状态&#10;                if self.server_update_callback:&#10;                    self.server_update_callback(&quot;未找到有效服务器&quot;, &quot;未找到有效服务器&quot;)&#10;&#10;        except Exception as e:&#10;            log(f&quot;服务器优化过程中发生错误: {e}&quot;)&#10;        finally:&#10;            # 执行内存清理&#10;            if hasattr(self, 'memory_manager'):&#10;                self.memory_manager.cleanup_if_needed()&#10;&#10;# ====================================================================&#10;# 核心业务逻辑模块&#10;# ====================================================================&#10;class CoreLogic:&#10;    &quot;&quot;&quot;核心业务逻辑控制器&quot;&quot;&quot;&#10;&#10;    def __init__(self, config_manager, status_callback, server_update_callback=None):&#10;        self.config = config_manager&#10;        self.status_callback = status_callback&#10;        self.server_update_callback = server_update_callback&#10;        &#10;        self.process_manager = ProcessManager()&#10;        self.startup_manager = StartupManager()&#10;        self.schedule_manager = ScheduleManager(config_manager, status_callback, server_update_callback)&#10;        &#10;        self.feishu_notifier = FeishuNotifier(&#10;            webhook_url=config_manager.get('feishu_webhook_url', ''),&#10;            at_all=config_manager.get('feishu_at_all', False)&#10;        )&#10;        self.monitoring_thread = None&#10;        self.start_monitoring()&#10;    &#10;    def restart_qmt(self):&#10;        &quot;&quot;&quot;立即重启QMT&quot;&quot;&quot;&#10;        self.schedule_manager.restart_qmt_service()&#10;    &#10;    def shutdown_qmt_now(self):&#10;        &quot;&quot;&quot;立即关闭QMT&quot;&quot;&quot;&#10;        self.schedule_manager.shutdown_qmt_service()&#10;    &#10;    def restart_rainbow_client(self):&#10;        &quot;&quot;&quot;立即重启彩虹客户端&quot;&quot;&quot;&#10;        self.schedule_manager.restart_rainbow_service()&#10;    &#10;    def shutdown_rainbow_now(self):&#10;        &quot;&quot;&quot;立即关闭彩虹客户端&quot;&quot;&quot;&#10;        self.schedule_manager.shutdown_rainbow_service()&#10;    &#10;    def delete_data_files_only(self):&#10;        &quot;&quot;&quot;仅删除数据文件，不重启彩虹客户端&quot;&quot;&quot;&#10;        self.schedule_manager.delete_data_files_service()&#10;    &#10;    def restart_rainbow_client_only(self):&#10;        &quot;&quot;&quot;仅重启彩虹客户端，不删除数据&quot;&quot;&quot;&#10;        self.schedule_manager.restart_rainbow_service_only()&#10;    &#10;    def shutdown_system_now(self):&#10;        &quot;&quot;&quot;立即关机&quot;&quot;&quot;&#10;        # 创建确认对话框&#10;        msg_box = QMessageBox()&#10;        msg_box.setWindowTitle(&quot;关机确认&quot;)&#10;        msg_box.setText(&quot;确认要关闭计算机吗？&quot;)&#10;        msg_box.setInformativeText(&quot;系统将在确认后1分钟内关机。&quot;)&#10;        msg_box.setStandardButtons(QMessageBox.Yes | QMessageBox.No)&#10;        msg_box.button(QMessageBox.Yes).setText(&quot;确认&quot;)&#10;        msg_box.button(QMessageBox.No).setText(&quot;取消&quot;)&#10;        msg_box.setDefaultButton(QMessageBox.No)  # 默认选中取消按钮，避免误操作&#10;        msg_box.setIcon(QMessageBox.Warning)&#10;&#10;        # 显示对话框并获取用户选择&#10;        result = msg_box.exec_()&#10;&#10;        # 只有用户点击确认按钮才执行关机&#10;        if result == QMessageBox.Yes:&#10;            self.schedule_manager.shutdown_system_service()&#10;&#10;    def toggle_startup(self, enable):&#10;        &quot;&quot;&quot;切换开机启动状态&quot;&quot;&quot;&#10;        if self.startup_manager.set_startup(enable):&#10;            self.status_callback(&quot;已设置开机启动&quot; if enable else &quot;已取消开机启动&quot;)&#10;            return True&#10;        else:&#10;            self.status_callback(&quot;设置开机启动失败&quot;)&#10;            return False&#10;    &#10;    def check_startup_status(self):&#10;        &quot;&quot;&quot;检查开机启动状态&quot;&quot;&quot;&#10;        return self.startup_manager.check_startup_status()&#10;    &#10;    def start_schedule(self):&#10;        &quot;&quot;&quot;启动定时任务&quot;&quot;&quot;&#10;        self.schedule_manager.start_schedule()&#10;    &#10;    def stop_schedule(self):&#10;        &quot;&quot;&quot;停止定时任务&quot;&quot;&quot;&#10;        self.schedule_manager.stop_schedule()&#10;    &#10;    @property&#10;    def is_schedule_running(self):&#10;        &quot;&quot;&quot;定时任务是否正在运行&quot;&quot;&quot;&#10;        return self.schedule_manager.is_running&#10;    &#10;    def start_monitoring(self):&#10;        &quot;&quot;&quot;启动实时监控&quot;&quot;&quot;&#10;        if self.monitoring_thread and self.monitoring_thread.is_alive():&#10;            log(&quot;监控线程已在运行&quot;)&#10;            return&#10;        &#10;        self.monitoring_thread = MonitoringThread(&#10;            config_manager=self.config,&#10;            feishu_notifier=self.feishu_notifier,&#10;            status_callback=self.status_callback,&#10;            server_update_callback=self.server_update_callback&#10;        )&#10;        self.monitoring_thread.start_monitoring()&#10;        log(&quot;实时监控已启动&quot;)&#10;        self.status_callback(&quot;实时监控已启动&quot;)&#10;    &#10;    def stop_monitoring(self):&#10;        &quot;&quot;&quot;停止实时监控&quot;&quot;&quot;&#10;        if self.monitoring_thread:&#10;            self.monitoring_thread.stop_monitoring()&#10;            self.monitoring_thread = None&#10;            log(&quot;实时监控已停止&quot;)&#10;            self.status_callback(&quot;实时监控已停止&quot;)&#10;    &#10;    @property&#10;    def is_monitoring_running(self):&#10;        &quot;&quot;&quot;监控是否正在运行&quot;&quot;&quot;&#10;        return self.monitoring_thread and self.monitoring_thread.is_alive()&#10;    &#10;    def update_monitoring_config(self):&#10;        &quot;&quot;&quot;更新监控配置&quot;&quot;&quot;&#10;        if self.monitoring_thread:&#10;            # 更新飞书通知器配置&#10;            self.feishu_notifier.webhook_url = self.config.get('feishu_webhook_url', '')&#10;            self.feishu_notifier.at_all = self.config.get('feishu_at_all', False)&#10;            &#10;            # 如果监控正在运行，重启以应用新配置&#10;            if self.is_monitoring_running:&#10;                self.stop_monitoring()&#10;                self.start_monitoring()&#10;&#10;# ====================================================================&#10;# UI样式表&#10;# ====================================================================&#10;STYLESHEET = &quot;&quot;&quot;&#10;QWidget {&#10;    background-color: #1e1e1e;&#10;    color: #d4d4d4;&#10;    font-family: 'Microsoft YaHei';&#10;    font-size: 22px;&#10;}&#10;QMainWindow {&#10;    background-color: #252526;&#10;}&#10;QTabWidget::pane {&#10;    border: 1px solid #3c3c3c;&#10;    border-radius: 4px;&#10;}&#10;QTabBar::tab {&#10;    background: #2d2d2d;&#10;    color: #d4d4d4;&#10;    padding: 10px 20px;&#10;    border-top-left-radius: 4px;&#10;    border-top-right-radius: 4px;&#10;    border: 1px solid #3c3c3c;&#10;    border-bottom: none;&#10;    margin-right: 2px;&#10;}&#10;QTabBar::tab:selected {&#10;    background: #1e1e1e;&#10;    color: #ffffff;&#10;    border-bottom: 1px solid #1e1e1e;&#10;}&#10;QGroupBox {&#10;    border: 1px solid #3c3c3c;&#10;    border-radius: 5px;&#10;    margin-top: 15px;&#10;    padding-top: 20px;&#10;    font-weight: bold;&#10;}&#10;QGroupBox::title {&#10;    subcontrol-origin: margin;&#10;    subcontrol-position: top left;&#10;    padding: 0 5px;&#10;    background-color: #1e1e1e;&#10;}&#10;QLineEdit {&#10;    background-color: #3c3c3c;&#10;    border: 1px solid #555;&#10;    border-radius: 4px;&#10;    padding: 5px;&#10;    color: #d4d4d4;&#10;}&#10;QLineEdit:read-only {&#10;    background-color: #2d2d2d;&#10;}&#10;QPushButton {&#10;    background-color: #0e639c;&#10;    color: white;&#10;    border: none;&#10;    padding: 12px 15px;&#10;    border-radius: 4px;&#10;    min-height: 30px;&#10;}&#10;QPushButton:hover {&#10;    background-color: #1177bb;&#10;}&#10;QPushButton:pressed {&#10;    background-color: #0c568a;&#10;}&#10;QCheckBox {&#10;    spacing: 5px;&#10;}&#10;QCheckBox::indicator {&#10;    width: 18px;&#10;    height: 18px;&#10;}&#10;QLabel#statusLabel {&#10;    font-size: 22px;&#10;    font-weight: bold;&#10;    color: #4ec9b0;&#10;}&#10;&quot;&quot;&quot;&#10;&#10;# ====================================================================&#10;# 主窗口UI模块&#10;# ====================================================================&#10;class MainWindow(QMainWindow):&#10;    &quot;&quot;&quot;主窗口界面&quot;&quot;&quot;&#10;    status_update_signal = Signal(str)&#10;    server_update_signal = Signal(str, str)&#10;&#10;    def __init__(self):&#10;        super().__init__()&#10;        &#10;        self.config_manager = ConfigManager()&#10;        self.memory_manager = MemoryManager()&#10;        self.async_manager = AsyncOperationManager(max_workers=4)&#10;        &#10;        self.init_ui()&#10;        self.connect_signals()&#10;        self.init_timers()&#10;        &#10;        self.core_logic = CoreLogic(&#10;            self.config_manager,&#10;            self.update_status_bar,&#10;            self.update_server_info&#10;        )&#10;        &#10;        self.core_logic.memory_manager = self.memory_manager&#10;        self.core_logic.async_manager = self.async_manager&#10;        &#10;        self.load_initial_state()&#10;&#10;    def init_ui(self):&#10;        &quot;&quot;&quot;初始化用户界面&quot;&quot;&quot;&#10;        self.setWindowTitle(&quot;∞MeowTech.实盘无限守护&quot;)&#10;        self.setGeometry(300, 300, 600, 500)&#10;        self.setStyleSheet(STYLESHEET)&#10;&#10;        self.tabs = QTabWidget()&#10;        self.setCentralWidget(self.tabs)&#10;&#10;        self.create_operation_page()&#10;        self.create_config_page()&#10;        &#10;        self.status_label = QLabel(&quot;就绪&quot;)&#10;        self.status_label.setObjectName(&quot;statusLabel&quot;)&#10;        self.statusBar().addWidget(self.status_label)&#10;&#10;    def connect_signals(self):&#10;        self.status_update_signal.connect(self.update_status_bar)&#10;        self.server_update_signal.connect(self.update_server_info)&#10;    &#10;    def init_timers(self):&#10;        self.timer = QTimer()&#10;        self.timer.timeout.connect(self.update_next_run_time)&#10;        self.timer.start(1000)&#10;    &#10;    def load_initial_state(self):&#10;        &quot;&quot;&quot;加载初始状态&quot;&quot;&quot;&#10;        if not StartupManager.diagnose_startup():&#10;            log(f&quot;✗ 开机启动诊断失败，可能存在权限或环境问题&quot;)&#10;        &#10;        config_startup = self.config_manager.get('enable_startup', False)&#10;        registry_startup = self.core_logic.check_startup_status()&#10;        &#10;        final_status = config_startup&#10;        &#10;        if config_startup != registry_startup:&#10;            log(f&quot;检测到状态不一致，开始同步&quot;)&#10;            &#10;            if self.core_logic.toggle_startup(config_startup):&#10;                new_registry_status = self.core_logic.check_startup_status()&#10;                if new_registry_status == config_startup:&#10;                    log(f&quot;✓ 同步成功&quot;)&#10;                    final_status = config_startup&#10;                else:&#10;                    final_status = registry_startup&#10;                    self.config_manager.set('enable_startup', registry_startup)&#10;                    log(f&quot;同步失败，已更新配置文件&quot;)&#10;            else:&#10;                # 同步失败，以注册表实际状态为准&#10;                final_status = registry_startup&#10;                self.config_manager.set('enable_startup', registry_startup)&#10;                log(f&quot;同步操作失败，已更新配置文件&quot;)&#10;        &#10;        # 4. 更新UI状态&#10;        self.update_button_states()&#10;        &#10;        # 5. 恢复定时任务状态&#10;        self.restore_schedule_state()&#10;        &#10;        # 6. 启动时自动重启QMT和彩虹客户端&#10;        self.perform_startup_restart()&#10;    &#10;    def restore_schedule_state(self):&#10;        &quot;&quot;&quot;恢复定时任务状态&quot;&quot;&quot;&#10;        try:&#10;            # 从配置文件读取上次的定时任务状态&#10;            was_schedule_running = self.config_manager.get('schedule_running', False)&#10;            &#10;            if was_schedule_running:&#10;                log(&quot;检测到上次定时任务处于运行状态，正在恢复...&quot;)&#10;                &#10;                # 验证配置有效性&#10;                qmt_dir = self.config_manager.get('qmt_dir')&#10;                qmt_time = self.config_manager.get('qmt_run_time')&#10;                &#10;                if os.path.exists(qmt_dir) and is_valid_time(qmt_time):&#10;                    self.core_logic.start_schedule()&#10;                    log(&quot;✓ 定时任务状态已恢复&quot;)&#10;                    # 更新UI按钮状态&#10;                    self.update_button_states()&#10;                else:&#10;                    log(&quot;✗ 配置验证失败，无法恢复定时任务状态&quot;)&#10;                    # 更新配置状态为未运行&#10;                    self.config_manager.set('schedule_running', False)&#10;                    self.config_manager.save_config()&#10;                    # 更新UI按钮状态&#10;                    self.update_button_states()&#10;            else:&#10;                log(&quot;上次定时任务未运行，保持停止状态&quot;)&#10;                &#10;        except Exception as e:&#10;            log(f&quot;恢复定时任务状态失败: {e}&quot;)&#10;            # 发生异常时确保状态为停止&#10;            self.config_manager.set('schedule_running', False)&#10;            self.config_manager.save_config()&#10;            # 更新UI按钮状态&#10;            self.update_button_states()&#10;    &#10;    def perform_startup_restart(self):&#10;        &quot;&quot;&quot;程序启动时自动重启QMT和彩虹客户端&quot;&quot;&quot;&#10;        log(&quot;程序启动检测：开始自动重启QMT和彩虹客户端...&quot;)&#10;        &#10;        def restart_worker():&#10;            try:&#10;                log(&quot;正在重启QMT...&quot;)&#10;                self.core_logic.restart_qmt()&#10;                &#10;                time.sleep(2)&#10;                &#10;                log(&quot;正在重启彩虹客户端...&quot;)&#10;                self.core_logic.restart_rainbow_client()&#10;                &#10;                log(&quot;✓ 启动时自动重启完成&quot;)&#10;                &#10;            except Exception as e:&#10;                log(f&quot;✗ 启动时自动重启失败: {e}&quot;)&#10;        &#10;        restart_thread = threading.Thread(target=restart_worker, daemon=True)&#10;        restart_thread.start()&#10;&#10;    def create_operation_page(self):&#10;        &quot;&quot;&quot;创建操作页面&quot;&quot;&quot;&#10;        page = QWidget()&#10;        layout = QVBoxLayout(page)&#10;        layout.setSpacing(20)&#10;&#10;        schedule_group = self._create_schedule_control_group()&#10;        qmt_group = self._create_qmt_control_group()&#10;        rainbow_group = self._create_rainbow_control_group()&#10;        system_group = self._create_system_control_group()&#10;        &#10;        layout.addWidget(qmt_group)&#10;        layout.addWidget(rainbow_group)&#10;        layout.addWidget(system_group)&#10;        layout.addWidget(schedule_group)&#10;        layout.addStretch()&#10;        &#10;        self.tabs.addTab(page, &quot;操作&quot;)&#10;    &#10;    def _create_qmt_control_group(self):&#10;        &quot;&quot;&quot;创建QMT控制组&quot;&quot;&quot;&#10;        qmt_group = QGroupBox(&quot;QMT 控制&quot;)&#10;        qmt_layout = QVBoxLayout()&#10;        qmt_layout.setSpacing(15)&#10;        &#10;        manual_qmt_layout = QHBoxLayout()&#10;        manual_qmt_layout.setSpacing(10)&#10;        restart_qmt_btn = QPushButton(&quot;立即重启QMT&quot;)&#10;        restart_qmt_btn.setStyleSheet(&quot;background-color: #4caf50; color: white; font-weight: bold;&quot;)&#10;        restart_qmt_btn.clicked.connect(lambda: Worker(self.core_logic.restart_qmt).start())&#10;        &#10;        shutdown_qmt_btn = QPushButton(&quot;立即关闭QMT&quot;)&#10;        shutdown_qmt_btn.clicked.connect(lambda: Worker(self.core_logic.shutdown_qmt_now).start())&#10;        &#10;        manual_qmt_layout.addWidget(restart_qmt_btn)&#10;        manual_qmt_layout.addWidget(shutdown_qmt_btn)&#10;        qmt_layout.addLayout(manual_qmt_layout)&#10;        &#10;        server_info_layout = QFormLayout()&#10;        self.best_hq_label = QLabel(&quot;待检测&quot;)&#10;        self.best_jy_label = QLabel(&quot;待检测&quot;)&#10;        server_info_layout.addRow(&quot;最佳行情服务器:&quot;, self.best_hq_label)&#10;        server_info_layout.addRow(&quot;最佳交易服务器:&quot;, self.best_jy_label)&#10;        &#10;        status_layout = QHBoxLayout()&#10;        self.network_status_label = QLabel(&quot;待检测&quot;)&#10;        self.network_status_label.setAlignment(Qt.AlignLeft)&#10;        self.qmt_process_label = QLabel(&quot;待检测&quot;)&#10;        self.qmt_process_label.setAlignment(Qt.AlignLeft)&#10;        &#10;        network_label = QLabel(&quot;网络状态:&quot;)&#10;        network_label.setAlignment(Qt.AlignLeft)&#10;        qmt_label = QLabel(&quot;  QMT进程:&quot;)&#10;        qmt_label.setAlignment(Qt.AlignLeft)&#10;        &#10;        status_layout.addWidget(network_label)&#10;        status_layout.addWidget(self.network_status_label)&#10;        status_layout.addWidget(qmt_label)&#10;        status_layout.addWidget(self.qmt_process_label)&#10;        status_layout.addStretch()&#10;        status_widget = QWidget()&#10;        status_widget.setLayout(status_layout)&#10;        server_info_layout.addRow(&quot;&quot;, status_widget)&#10;        &#10;        qmt_layout.addLayout(server_info_layout)&#10;&#10;        qmt_group.setLayout(qmt_layout)&#10;        return qmt_group&#10;    &#10;    def _create_rainbow_control_group(self):&#10;        &quot;&quot;&quot;创建彩虹客户端控制组&quot;&quot;&quot;&#10;        rainbow_group = QGroupBox(&quot;彩虹客户端控制&quot;)&#10;        rainbow_layout = QVBoxLayout()&#10;        rainbow_layout.setSpacing(10)&#10;        &#10;        # 手动操作按钮&#10;        restart_rainbow_btn = QPushButton(&quot;立即重启彩虹客户端&quot;)&#10;        restart_rainbow_btn.setStyleSheet(&quot;background-color: #4caf50; color: white; font-weight: bold;&quot;)&#10;        restart_rainbow_btn.clicked.connect(lambda: Worker(self.core_logic.restart_rainbow_client_only).start())&#10;        rainbow_layout.addWidget(restart_rainbow_btn)&#10;        &#10;        shutdown_rainbow_btn = QPushButton(&quot;立即关闭彩虹客户端&quot;)&#10;        shutdown_rainbow_btn.clicked.connect(lambda: Worker(self.core_logic.shutdown_rainbow_now).start())&#10;        rainbow_layout.addWidget(shutdown_rainbow_btn)&#10;        &#10;        # 新增：独立的删除数据文件按钮&#10;        delete_data_btn = QPushButton(&quot;删除数据文件&quot;)&#10;        delete_data_btn.clicked.connect(lambda: Worker(self.core_logic.delete_data_files_only).start())&#10;        rainbow_layout.addWidget(delete_data_btn)&#10;        &#10;        rainbow_group.setLayout(rainbow_layout)&#10;        return rainbow_group&#10;    &#10;    def _create_schedule_control_group(self):&#10;        &quot;&quot;&quot;创建定时任务总控&quot;&quot;&quot;&#10;        group = QGroupBox(&quot;定时任务总控&quot;)&#10;        layout = QVBoxLayout()&#10;        layout.setSpacing(15)&#10;&#10;        self.schedule_btn = QPushButton(&quot;启动总定时器&quot;)&#10;        self.schedule_btn.setCheckable(True)&#10;        self.schedule_btn.clicked.connect(self.toggle_schedule)&#10;&#10;        self.next_run_label = QLabel(&quot;下次运行时间:\n定时任务未启动&quot;)&#10;        self.next_run_label.setAlignment(Qt.AlignLeft)&#10;        self.next_run_label.setStyleSheet(&quot;font-size: 24px; color: #4ec9b0; font-weight: bold;&quot;)&#10;&#10;        layout.addWidget(self.schedule_btn)&#10;        layout.addWidget(self.next_run_label)&#10;&#10;        group.setLayout(layout)&#10;        return group&#10;&#10;    def _create_system_control_group(self):&#10;        &quot;&quot;&quot;创建系统控制组&quot;&quot;&quot;&#10;        system_group = QGroupBox(&quot;系统控制&quot;)&#10;        system_layout = QVBoxLayout()&#10;        system_layout.setSpacing(10)&#10;        &#10;        self.startup_btn = QPushButton(&quot;设置开机启动&quot;)&#10;        self.startup_btn.clicked.connect(self.toggle_startup)&#10;        system_layout.addWidget(self.startup_btn)&#10;&#10;        shutdown_system_btn = QPushButton(&quot;立即关机&quot;)&#10;        # 修复: 不能在后台线程中创建/执行 QMessageBox，否则会导致窗口卡死“未响应”&#10;        # 原实现: shutdown_system_btn.clicked.connect(lambda: Worker(self.core_logic.shutdown_system_now).start())&#10;        shutdown_system_btn.clicked.connect(self.core_logic.shutdown_system_now)&#10;        system_layout.addWidget(shutdown_system_btn)&#10;&#10;        system_group.setLayout(system_layout)&#10;        return system_group&#10;    &#10;&#10;&#10;    def create_config_page(self):&#10;        &quot;&quot;&quot;创建配置页面&quot;&quot;&quot;&#10;        page = QWidget()&#10;        layout = QVBoxLayout(page)&#10;&#10;        qmt_group = self._create_qmt_config_group()&#10;        rainbow_group = self._create_rainbow_config_group()&#10;        delete_group = self._create_delete_config_group()&#10;        system_monitoring_group = self._create_system_monitoring_config_group()&#10;        &#10;        button_layout = QHBoxLayout()&#10;        &#10;        button_layout.addStretch()&#10;        &#10;        save_btn = QPushButton(&quot;保存配置&quot;)&#10;        save_btn.clicked.connect(self.save_config)&#10;        button_layout.addWidget(save_btn)&#10;&#10;        layout.addWidget(qmt_group)&#10;        layout.addWidget(rainbow_group)&#10;        layout.addWidget(delete_group)&#10;        layout.addWidget(system_monitoring_group)&#10;        layout.addLayout(button_layout)&#10;        layout.addStretch()&#10;        &#10;        self.tabs.addTab(page, &quot;配置&quot;)&#10;    &#10;    def _create_qmt_config_group(self):&#10;        &quot;&quot;&quot;创建QMT配置组&quot;&quot;&quot;&#10;        qmt_group = QGroupBox(&quot;QMT 配置&quot;)&#10;        qmt_form = QFormLayout()&#10;        &#10;        self.qmt_dir_input = QLineEdit(self.config_manager.get('qmt_dir'))&#10;        self.qmt_run_time_input = QLineEdit(self.config_manager.get('qmt_run_time'))&#10;        self.qmt_run_time_input.setPlaceholderText(&quot;留空则不执行&quot;)&#10;        self.qmt_shutdown_time_edit = QLineEdit(self.config_manager.get('qmt_shutdown_time', '15:05:00'))&#10;        self.qmt_shutdown_time_edit.setPlaceholderText(&quot;留空则不执行&quot;)&#10;        self.qmt_only_vip_checkbox = QCheckBox(&quot;仅使用VIP服务器&quot;)&#10;        self.qmt_only_vip_checkbox.setChecked(self.config_manager.get(&quot;qmt_only_vip&quot;, True))&#10;        &#10;        # 创建定时时间范围的水平布局&#10;        qmt_time_widget = QWidget()&#10;        qmt_time_layout = QHBoxLayout(qmt_time_widget)&#10;        qmt_time_layout.setContentsMargins(0, 0, 0, 0)&#10;        qmt_time_layout.addWidget(self.qmt_run_time_input)&#10;        qmt_time_layout.addWidget(QLabel(&quot; / &quot;))&#10;        qmt_time_layout.addWidget(self.qmt_shutdown_time_edit)&#10;        &#10;        qmt_form.addRow(&quot;QMT 路径:&quot;, self.qmt_dir_input)&#10;        qmt_form.addRow(&quot;定时 重启/关闭:&quot;, qmt_time_widget)&#10;        qmt_form.addRow(&quot;&quot;, self.qmt_only_vip_checkbox)&#10;        &#10;        qmt_group.setLayout(qmt_form)&#10;        return qmt_group&#10;    &#10;    def _create_rainbow_config_group(self):&#10;        &quot;&quot;&quot;创建彩虹客户端配置组&quot;&quot;&quot;&#10;        rainbow_group = QGroupBox(&quot;彩虹客户端配置&quot;)&#10;        rainbow_form = QFormLayout()&#10;        &#10;        self.rainbow_exe_path_input = QLineEdit(self.config_manager.get('rainbow_exe_path'))&#10;        self.rainbow_restart_time_input = QLineEdit(self.config_manager.get('rainbow_restart_time'))&#10;        self.rainbow_restart_time_input.setPlaceholderText(&quot;留空则不执行&quot;)&#10;        self.rainbow_shutdown_time_edit = QLineEdit(self.config_manager.get('rainbow_shutdown_time', '15:10:00'))&#10;        self.rainbow_shutdown_time_edit.setPlaceholderText(&quot;留空则不执行&quot;)&#10;        &#10;        rainbow_time_widget = QWidget()&#10;        rainbow_time_layout = QHBoxLayout(rainbow_time_widget)&#10;        rainbow_time_layout.setContentsMargins(0, 0, 0, 0)&#10;        rainbow_time_layout.addWidget(self.rainbow_restart_time_input)&#10;        rainbow_time_layout.addWidget(QLabel(&quot; / &quot;))&#10;        rainbow_time_layout.addWidget(self.rainbow_shutdown_time_edit)&#10;        &#10;        rainbow_form.addRow(&quot;彩虹客户端路径:&quot;, self.rainbow_exe_path_input)&#10;        rainbow_form.addRow(&quot;定时 重启/关闭:&quot;, rainbow_time_widget)&#10;        &#10;        rainbow_group.setLayout(rainbow_form)&#10;        return rainbow_group&#10;    &#10;    def _create_delete_config_group(self):&#10;        &quot;&quot;&quot;创建数据删除配置组&quot;&quot;&quot;&#10;        delete_group = QGroupBox(&quot;数据删除配置&quot;)&#10;        delete_form = QFormLayout()&#10;        &#10;        self.delete_base_path_input = QLineEdit(self.config_manager.get('delete_base_path'))&#10;        self.delete_folders_input = QLineEdit(self.config_manager.get('delete_folders'))&#10;        &#10;        delete_form.addRow(&quot;基础路径:&quot;, self.delete_base_path_input)&#10;        delete_form.addRow(&quot;文件夹名称 (逗号分隔):&quot;, self.delete_folders_input)&#10;        &#10;        delete_group.setLayout(delete_form)&#10;        return delete_group&#10;    &#10;    def _create_system_monitoring_config_group(self):&#10;        &quot;&quot;&quot;创建系统监控配置组&quot;&quot;&quot;&#10;        system_monitoring_group = QGroupBox(&quot;系统监控配置&quot;)&#10;        system_monitoring_form = QFormLayout()&#10;        &#10;        # 定时关机配置&#10;        self.system_shutdown_time_edit = QLineEdit(self.config_manager.get('system_shutdown_time', '15:30:00'))&#10;        self.system_shutdown_time_edit.setPlaceholderText(&quot;留空则不执行&quot;)&#10;        system_monitoring_form.addRow(&quot;定时关机:&quot;, self.system_shutdown_time_edit)&#10;        &#10;        # 监控间隔配置&#10;        self.monitor_interval_input = QLineEdit(str(self.config_manager.get('monitor_interval', 10)))&#10;        self.monitor_interval_input.setPlaceholderText(&quot;监控间隔（秒）&quot;)&#10;        self.notification_interval_input = QLineEdit(str(self.config_manager.get('notification_interval', 300)))&#10;        self.notification_interval_input.setPlaceholderText(&quot;通知间隔（秒）&quot;)&#10;        &#10;        interval_widget = QWidget()&#10;        interval_layout = QHBoxLayout(interval_widget)&#10;        interval_layout.setContentsMargins(0, 0, 0, 0)&#10;        interval_layout.addWidget(self.monitor_interval_input)&#10;        interval_layout.addWidget(QLabel(&quot; / &quot;))&#10;        interval_layout.addWidget(self.notification_interval_input)&#10;        &#10;        system_monitoring_form.addRow(&quot;监控/通知 间隔(秒):&quot;, interval_widget)&#10;        &#10;        # 通知时间范围配置&#10;        self.notification_start_time_input = QLineEdit(self.config_manager.get('notification_start_time', '09:00:00'))&#10;        self.notification_start_time_input.setPlaceholderText(&quot;HH:MM:SS&quot;)&#10;        self.notification_end_time_input = QLineEdit(self.config_manager.get('notification_end_time', '15:30:00'))&#10;        self.notification_end_time_input.setPlaceholderText(&quot;HH:MM:SS&quot;)&#10;        &#10;        time_range_widget = QWidget()&#10;        time_range_layout = QHBoxLayout(time_range_widget)&#10;        time_range_layout.setContentsMargins(0, 0, 0, 0)&#10;        time_range_layout.addWidget(self.notification_start_time_input)&#10;        time_range_layout.addWidget(QLabel(&quot; - &quot;))&#10;        time_range_layout.addWidget(self.notification_end_time_input)&#10;        &#10;        system_monitoring_form.addRow(&quot;通知时间范围:&quot;, time_range_widget)&#10;        &#10;        # 飞书通知配置&#10;        self.feishu_webhook_input = QLineEdit(self.config_manager.get('feishu_webhook_url', ''))&#10;        self.feishu_webhook_input.setPlaceholderText(&quot;飞书机器人Webhook URL（配置即开启通知，默认@所有人）&quot;)&#10;        # 设置更长的输入框最小宽度&#10;        self.feishu_webhook_input.setMinimumWidth(400)&#10;        &#10;        system_monitoring_form.addRow(&quot;飞书Webhook:&quot;, self.feishu_webhook_input)&#10;        &#10;        system_monitoring_group.setLayout(system_monitoring_form)&#10;        return system_monitoring_group&#10;    def toggle_schedule(self):&#10;        &quot;&quot;&quot;切换定时任务状态&quot;&quot;&quot;&#10;        if self.core_logic.is_schedule_running:&#10;            self.core_logic.stop_schedule()&#10;            # 保存定时任务停止状态&#10;            self.config_manager.set('schedule_running', False)&#10;            self.config_manager.save_config()&#10;        else:&#10;            qmt_dir = self.config_manager.get('qmt_dir')&#10;            qmt_time = self.config_manager.get('qmt_run_time')&#10;            &#10;            if not os.path.exists(qmt_dir):&#10;                QMessageBox.warning(self, &quot;错误&quot;, &quot;QMT 路径不存在，请检查配置&quot;)&#10;                return&#10;            &#10;            if not is_valid_time(qmt_time):&#10;                QMessageBox.warning(self, &quot;错误&quot;, &quot;QMT 定时重启时间格式不正确&quot;)&#10;                return&#10;            &#10;            self.core_logic.start_schedule()&#10;            # 保存定时任务启动状态&#10;            self.config_manager.set('schedule_running', True)&#10;            self.config_manager.save_config()&#10;        &#10;        self.update_button_states()&#10;    &#10;    def toggle_monitoring(self):&#10;        &quot;&quot;&quot;切换监控状态&quot;&quot;&quot;&#10;        if self.core_logic.is_monitoring_running:&#10;            self.core_logic.stop_monitoring()&#10;        else:&#10;            self.core_logic.start_monitoring()&#10;    &#10;&#10;    &#10;    def toggle_startup(self):&#10;        &quot;&quot;&quot;切换开机启动状态&quot;&quot;&quot;&#10;        current_status = self.config_manager.get('enable_startup', False)&#10;        target_status = not current_status&#10;        &#10;        if not StartupManager.diagnose_startup():&#10;            QMessageBox.warning(self, &quot;警告&quot;, &#10;                              &quot;开机启动环境检查失败，可能存在权限问题。\n&quot;&#10;                              &quot;请尝试以管理员身份运行程序。&quot;)&#10;            return&#10;        &#10;        if self.core_logic.toggle_startup(target_status):&#10;            actual_status = self.core_logic.check_startup_status()&#10;            &#10;            if actual_status == target_status:&#10;                self.config_manager.set('enable_startup', target_status)&#10;                self.update_button_states()&#10;                &#10;                success_msg = &quot;✓ 开机启动已启用&quot; if target_status else &quot;✓ 开机启动已禁用&quot;&#10;                log(f&quot;{success_msg}&quot;)&#10;                QMessageBox.information(self, &quot;成功&quot;, success_msg)&#10;            else:&#10;                error_msg = f&quot;设置操作完成，但验证失败\n期望状态: {target_status}\n实际状态: {actual_status}&quot;&#10;                log(f&quot;✗ {error_msg}&quot;)&#10;                QMessageBox.warning(self, &quot;警告&quot;, error_msg)&#10;                &#10;                # 以实际状态为准更新配置&#10;                self.config_manager.set('enable_startup', actual_status)&#10;                self.update_button_states()&#10;        else:&#10;            # 操作失败&#10;            error_msg = f&quot;{'启用' if target_status else '禁用'}开机启动失败\n请检查系统权限或重试&quot;&#10;            log(f&quot;✗ {error_msg}&quot;)&#10;            QMessageBox.critical(self, &quot;错误&quot;, error_msg)&#10;&#10;    # ----------------------------------------------------------------&#10;    # 配置管理&#10;    def save_config(self):&#10;        &quot;&quot;&quot;保存配置&quot;&quot;&quot;&#10;        qmt_time = self.qmt_run_time_input.text().strip()&#10;        qmt_shutdown_time = self.qmt_shutdown_time_edit.text().strip()&#10;        rainbow_time = self.rainbow_restart_time_input.text().strip()&#10;        rainbow_shutdown_time = self.rainbow_shutdown_time_edit.text().strip()&#10;        system_shutdown_time = self.system_shutdown_time_edit.text().strip()&#10;        &#10;        if not is_valid_time(qmt_time):&#10;            QMessageBox.warning(self, &quot;错误&quot;, &quot;QMT定时重启时间格式不正确，请使用 HH:MM:SS 格式或留空不启用&quot;)&#10;            return&#10;        &#10;        if not is_valid_time(qmt_shutdown_time):&#10;            QMessageBox.warning(self, &quot;错误&quot;, &quot;QMT定时关闭时间格式不正确，请使用 HH:MM:SS 格式或留空不执行&quot;)&#10;            return&#10;        &#10;        if not is_valid_time(rainbow_time):&#10;            QMessageBox.warning(self, &quot;错误&quot;, &quot;彩虹客户端定时重启时间格式不正确，请使用 HH:MM:SS 格式或留空不启用&quot;)&#10;            return&#10;        &#10;        if not is_valid_time(rainbow_shutdown_time):&#10;            QMessageBox.warning(self, &quot;错误&quot;, &quot;彩虹客户端定时关闭时间格式不正确，请使用 HH:MM:SS 格式或留空不执行&quot;)&#10;            return&#10;        &#10;        if not is_valid_time(system_shutdown_time):&#10;            QMessageBox.warning(self, &quot;错误&quot;, &quot;系统定时关机时间格式不正确，请使用 HH:MM:SS 格式或留空不执行&quot;)&#10;            return&#10;        &#10;        monitor_interval = self.monitor_interval_input.text().strip()&#10;        notification_interval = self.notification_interval_input.text().strip()&#10;        notification_start_time = self.notification_start_time_input.text().strip()&#10;        notification_end_time = self.notification_end_time_input.text().strip()&#10;        &#10;        try:&#10;            if monitor_interval:&#10;                int(monitor_interval)&#10;            if notification_interval:&#10;                int(notification_interval)&#10;        except ValueError:&#10;            QMessageBox.warning(self, &quot;错误&quot;, &quot;监控间隔和通知间隔必须是数字&quot;)&#10;            return&#10;        &#10;        if not is_valid_time(notification_start_time):&#10;            QMessageBox.warning(self, &quot;错误&quot;, &quot;通知开始时间格式不正确，请使用 HH:MM:SS 格式&quot;)&#10;            return&#10;        &#10;        if not is_valid_time(notification_end_time):&#10;            QMessageBox.warning(self, &quot;错误&quot;, &quot;通知结束时间格式不正确，请使用 HH:MM:SS 格式&quot;)&#10;            return&#10;        &#10;        config_updates = {&#10;            'qmt_dir': self.qmt_dir_input.text().strip(),&#10;            'qmt_run_time': qmt_time,&#10;            'qmt_shutdown_time': qmt_shutdown_time,&#10;            'qmt_only_vip': self.qmt_only_vip_checkbox.isChecked(),&#10;            'rainbow_exe_path': self.rainbow_exe_path_input.text().strip(),&#10;            'rainbow_restart_time': rainbow_time,&#10;            'rainbow_shutdown_time': rainbow_shutdown_time,&#10;            'delete_base_path': self.delete_base_path_input.text().strip(),&#10;            'delete_folders': self.delete_folders_input.text().strip(),&#10;            'system_shutdown_time': system_shutdown_time,&#10;            'monitor_interval': int(monitor_interval) if monitor_interval else 10,&#10;            'notification_interval': int(notification_interval) if notification_interval else 300,&#10;            'notification_start_time': notification_start_time,&#10;            'notification_end_time': notification_end_time,&#10;            'enable_feishu_notification': bool(self.feishu_webhook_input.text().strip()),&#10;            'feishu_webhook_url': self.feishu_webhook_input.text().strip(),&#10;            'feishu_at_all': True&#10;        }&#10;        &#10;        self.config_manager.update(config_updates)&#10;        &#10;        if self.config_manager.save_config():&#10;            self.update_status_bar(&quot;配置已保存！&quot;)&#10;            &#10;            # 自动测试飞书通知&#10;            feishu_url = self.feishu_webhook_input.text().strip()&#10;            if feishu_url:&#10;                try:&#10;                    test_notifier = FeishuNotifier(&#10;                        webhook_url=feishu_url,&#10;                        at_all=self.config_manager.get('feishu_at_all', False)&#10;                    )&#10;                    &#10;                    success = test_notifier.send_message(&#10;                        title=&quot; 配置保存测试通知&quot;,&#10;                        content=&quot;配置已成功保存，这是一条来自∞MeowTech.实盘无限守护的测试通知&quot;,&#10;                        msg_type=&quot;info&quot;&#10;                    )&#10;                    &#10;                    if success:&#10;                        QMessageBox.information(self, &quot;成功&quot;, &quot;配置已成功保存！\n飞书通知测试成功！&quot;)&#10;                        self.update_status_bar(&quot;配置已保存，飞书通知测试成功&quot;)&#10;                    else:&#10;                        QMessageBox.warning(self, &quot;部分成功&quot;, &quot;配置已成功保存！\n但飞书通知测试失败，请检查Webhook URL&quot;)&#10;                        self.update_status_bar(&quot;配置已保存，飞书通知测试失败&quot;)&#10;                        &#10;                except Exception as e:&#10;                    QMessageBox.warning(self, &quot;部分成功&quot;, f&quot;配置已成功保存！\n但飞书通知测试时发生错误: {str(e)}&quot;)&#10;                    self.update_status_bar(f&quot;配置已保存，飞书通知测试错误: {str(e)}&quot;)&#10;            else:&#10;                QMessageBox.information(self, &quot;成功&quot;, &quot;配置已成功保存！&quot;)&#10;        else:&#10;            QMessageBox.warning(self, &quot;错误&quot;, &quot;配置保存失败！&quot;)&#10;        &#10;        if self.core_logic.is_schedule_running:&#10;            self.core_logic.stop_schedule()&#10;            self.core_logic.start_schedule()&#10;        &#10;        self.core_logic.update_monitoring_config()&#10;        &#10;        self.update_button_states()&#10;    &#10;    def closeEvent(self, event):&#10;        &quot;&quot;&quot;关闭窗口前保存配置并清理资源&quot;&quot;&quot;&#10;        try:&#10;            self.config_manager.save_config()&#10;            &#10;            if hasattr(self, 'async_manager'):&#10;                self.async_manager.shutdown()&#10;                &#10;            # 强制清理内存&#10;            if hasattr(self, 'memory_manager'):&#10;                self.memory_manager.force_cleanup()&#10;                &#10;            log(&quot;程序资源清理完成&quot;)&#10;        except Exception as e:&#10;            log(f&quot;资源清理时发生错误: {e}&quot;)&#10;        finally:&#10;            super().closeEvent(event)&#10;&#10;    def update_button_states(self):&#10;        &quot;&quot;&quot;更新按钮状态和文本&quot;&quot;&quot;&#10;        if self.core_logic.is_schedule_running:&#10;            self.schedule_btn.setText(&quot;停止定时任务&quot;)&#10;            self.schedule_btn.setStyleSheet(&quot;background-color: #f44336; color: white;&quot;)&#10;        else:&#10;            self.schedule_btn.setText(&quot;启动定时任务&quot;)&#10;            self.schedule_btn.setStyleSheet(&quot;background-color: #4caf50; color: white;&quot;)&#10;        &#10;        if self.config_manager.get('enable_startup', False):&#10;            self.startup_btn.setText(&quot;取消开机启动&quot;)&#10;            self.startup_btn.setStyleSheet(&quot;background-color: #ff9800; color: white;&quot;)&#10;        else:&#10;            self.startup_btn.setText(&quot;设置开机启动&quot;)&#10;            self.startup_btn.setStyleSheet(&quot;background-color: #2196f3; color: white;&quot;)&#10;&#10;&#10;    &#10;    def update_next_run_time(self):&#10;        &quot;&quot;&quot;更新下次运行时间显示并监控内存使用情况&quot;&quot;&quot;&#10;        if hasattr(self, 'memory_manager'):&#10;            self.memory_manager.cleanup_if_needed()&#10;            &#10;        if self.core_logic.is_schedule_running:&#10;            next_run = schedule.next_run()&#10;            if next_run:&#10;                restart_tasks = []&#10;                shutdown_tasks = []&#10;                system_tasks = []&#10;                &#10;                qmt_time = self.config_manager.get('qmt_run_time')&#10;                if qmt_time:&#10;                    restart_tasks.append(f&quot;QMT重启: {qmt_time}&quot;)&#10;                &#10;                rainbow_time = self.config_manager.get('rainbow_restart_time')&#10;                if rainbow_time:&#10;                    restart_tasks.append(f&quot;彩虹重启: {rainbow_time}&quot;)&#10;                &#10;                qmt_shutdown_time = self.config_manager.get('qmt_shutdown_time')&#10;                if qmt_shutdown_time:&#10;                    shutdown_tasks.append(f&quot;QMT关闭: {qmt_shutdown_time}&quot;)&#10;                &#10;                rainbow_shutdown_time = self.config_manager.get('rainbow_shutdown_time')&#10;                if rainbow_shutdown_time:&#10;                    shutdown_tasks.append(f&quot;彩虹关闭: {rainbow_shutdown_time}&quot;)&#10;                &#10;                system_shutdown_time = self.config_manager.get('system_shutdown_time')&#10;                if system_shutdown_time:&#10;                    system_tasks.append(f&quot;系统关机: {system_shutdown_time}&quot;)&#10;                &#10;                status_lines = [&quot;下次运行时间:&quot;]&#10;                if restart_tasks:&#10;                    status_lines.append(&quot;重启任务: &quot; + &quot; / &quot;.join(restart_tasks))&#10;                if shutdown_tasks:&#10;                    status_lines.append(&quot;关闭任务: &quot; + &quot; / &quot;.join(shutdown_tasks))&#10;                if system_tasks:&#10;                    status_lines.append(&quot;系统任务: &quot; + &quot; / &quot;.join(system_tasks))&#10;                &#10;                if len(status_lines) &gt; 1:&#10;                    status = &quot;\n&quot;.join(status_lines)&#10;                else:&#10;                    status = &quot;下次运行时间:\n无有效任务配置&quot;&#10;            else:&#10;                status = &quot;下次运行时间: 计算中...&quot;&#10;        else:&#10;            status = &quot;下次运行时间: 定时任务未启动&quot;&#10;        &#10;        self.next_run_label.setText(status)&#10;        &#10;        self.update_monitoring_status()&#10;    &#10;    def update_status_bar(self, message):&#10;        &quot;&quot;&quot;线程安全地更新状态栏文本&quot;&quot;&quot;&#10;        if threading.current_thread() is not threading.main_thread():&#10;            self.status_update_signal.emit(message)&#10;        else:&#10;            log(message)&#10;            self.status_label.setText(message)&#10;    &#10;    def update_server_info(self, hq_info, jy_info):&#10;        &quot;&quot;&quot;更新服务器信息显示&quot;&quot;&quot;&#10;        if threading.current_thread() is not threading.main_thread():&#10;            self.server_update_signal.emit(hq_info, jy_info)&#10;        else:&#10;            self.best_hq_label.setText(hq_info)&#10;            self.best_jy_label.setText(jy_info)&#10;    &#10;    def update_monitoring_status(self):&#10;        &quot;&quot;&quot;更新监控状态显示并检查内存使用情况&quot;&quot;&quot;&#10;        try:&#10;            if hasattr(self, 'memory_manager'):&#10;                self.memory_manager.cleanup_if_needed()&#10;                &#10;            if hasattr(self, 'network_status_label') and hasattr(self, 'qmt_process_label'):&#10;                is_running = self.core_logic.is_monitoring_running&#10;                if is_running and hasattr(self.core_logic, 'monitoring_thread') and self.core_logic.monitoring_thread:&#10;                    network_status = &quot;正常&quot; if self.core_logic.monitoring_thread.last_network_status else &quot;异常&quot;&#10;                    qmt_status = &quot;运行中&quot; if self.core_logic.monitoring_thread.last_qmt_status else &quot;未运行&quot;&#10;                    &#10;                    # 内存显示已移除&#10;                    &#10;                    self.network_status_label.setText(network_status)&#10;                    self.qmt_process_label.setText(qmt_status)&#10;                    &#10;                    network_color = &quot;#51cf66&quot; if self.core_logic.monitoring_thread.last_network_status else &quot;#ff6b6b&quot;&#10;                    qmt_color = &quot;#51cf66&quot; if self.core_logic.monitoring_thread.last_qmt_status else &quot;#ff6b6b&quot;&#10;                    &#10;                    self.network_status_label.setStyleSheet(f&quot;color: {network_color}; font-weight: bold; font-size: 14px;&quot;)&#10;                    self.qmt_process_label.setStyleSheet(f&quot;color: {qmt_color}; font-weight: bold; font-size: 14px;&quot;)&#10;                else:&#10;                    self.network_status_label.setText(&quot;待检测&quot;)&#10;                    self.qmt_process_label.setText(&quot;待检测&quot;)&#10;                    self.network_status_label.setStyleSheet(&quot;color: #868e96; font-size: 14px;&quot;)&#10;                    self.qmt_process_label.setStyleSheet(&quot;color: #868e96; font-size: 14px;&quot;)&#10;        except Exception as e:&#10;            log(f&quot;更新监控状态显示时发生错误: {e}&quot;)&#10;&#10;def main():&#10;    &quot;&quot;&quot;程序主入口&quot;&quot;&quot;&#10;    app = QApplication(sys.argv)&#10;    app.setApplicationName(&quot;QMT彩虹客户端工具&quot;)&#10;    app.setApplicationVersion(&quot;2.2.31&quot;)&#10;&#10;    window = MainWindow()&#10;    window.show()&#10;&#10;    log(&quot;=&quot;*60)&#10;    log(&quot;∞MeowTech.实盘无限守护&quot;)&#10;    log(&quot;功能：QMT和彩虹客户端的自动化管理工具&quot;)&#10;    log(&quot;=&quot;*60)&#10;&#10;    sys.exit(app.exec())&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    main()&#10;" />
              <option name="updatedContent" value="&quot;&quot;&quot;实盘无限守护 - QMT和彩虹客户端自动化管理工具&#10;作者： ∞MeowTech @萌新小强 @无限进化 @萌新小王 @大蒜&#10;版本：3.0&#10;&quot;&quot;&quot;&#10;&#10;# ====================================================================&#10;# USER CONFIG - 用户配置区域（集中管理所有可调参数）&#10;# ====================================================================&#10;class Constants:&#10;    &quot;&quot;&quot;系统常量配置 - 集中管理可调参数&quot;&quot;&quot;&#10;    &#10;    # 进程管理&#10;    GRACEFUL_SHUTDOWN_TIMEOUT = 10  # 优雅关闭超时（秒）&#10;    FORCE_KILL_TIMEOUT = 5         # 强制终止超时（秒）&#10;    PROCESS_START_TIMEOUT = 30     # 进程启动超时（秒）&#10;    &#10;    # 网络测试&#10;    NETWORK_TEST_TIMEOUT = 0.1     # 网络延迟测试超时（秒）&#10;    NETWORK_TEST_SAMPLES = 5       # 延迟测试样本数&#10;    MAX_ACCEPTABLE_LATENCY = 1000  # 最大可接受延迟（毫秒）&#10;    &#10;    # 监控配置&#10;    DEFAULT_MONITOR_INTERVAL = 60      # 监控间隔（秒）&#10;    DEFAULT_NOTIFICATION_INTERVAL = 300 # 通知间隔（秒）&#10;    MEMORY_WARNING_THRESHOLD = 1000    # 内存警告阈值（MB）&#10;    CPU_WARNING_THRESHOLD = 80         # CPU警告阈值（%）&#10;    &#10;    # UI配置&#10;    UI_UPDATE_INTERVAL = 1000      # UI更新间隔（毫秒）&#10;    ASYNC_OPERATION_TIMEOUT = 60   # 异步操作超时（秒）&#10;    STATUS_MESSAGE_MAX_LENGTH = 100 # 状态消息最大长度&#10;    &#10;    # 文件路径&#10;    CONFIG_FILENAME = &quot;guardian_config.json&quot;&#10;    LOG_DIR_NAME = &quot;logs&quot;&#10;    CACHE_DIR_NAME = &quot;cache&quot;&#10;    &#10;    # 进程名称&#10;    QMT_PROCESS_NAME = &quot;XtMiniQmt.exe&quot;&#10;    QMT_CLIENT_PROCESS_NAME = &quot;XtItClient.exe&quot;&#10;    &#10;    # 时间格式&#10;    TIME_FORMAT = &quot;%H:%M:%S&quot;&#10;    DATETIME_FORMAT = &quot;%Y-%m-%d %H:%M:%S&quot;&#10;    &#10;    # 飞书通知&#10;    FEISHU_TIMEOUT = 10           # 通知超时（秒）&#10;    FEISHU_RETRY_COUNT = 3        # 重试次数&#10;    FEISHU_RETRY_DELAY = 2        # 重试延迟（秒）&#10;&#10;# ====================================================================&#10;# 内存管理和异步操作辅助类&#10;# ====================================================================&#10;class MemoryManager:&#10;    &quot;&quot;&quot;内存管理器 - 定期清理大对象，防止内存泄漏&quot;&quot;&quot;&#10;    &#10;    def __init__(self):&#10;        self._large_objects = weakref.WeakSet()  # 使用弱引用避免循环引用&#10;        self._last_cleanup = time.time()&#10;        self._cleanup_interval = 300  # 5分钟清理一次&#10;        &#10;    def register_large_object(self, obj):&#10;        &quot;&quot;&quot;注册大对象用于监控&quot;&quot;&quot;&#10;        self._large_objects.add(obj)&#10;        &#10;    def cleanup_if_needed(self):&#10;        &quot;&quot;&quot;根据需要执行内存清理&quot;&quot;&quot;&#10;        current_time = time.time()&#10;        if current_time - self._last_cleanup &gt; self._cleanup_interval:&#10;            self.force_cleanup()&#10;            &#10;    def force_cleanup(self):&#10;        &quot;&quot;&quot;强制执行内存清理&quot;&quot;&quot;&#10;        # 清理大对象缓存&#10;        for obj in list(self._large_objects):&#10;            if hasattr(obj, 'clear_cache'):&#10;                obj.clear_cache()&#10;                &#10;        # 执行垃圾回收&#10;        collected = gc.collect()&#10;        self._last_cleanup = time.time()&#10;        &#10;        if collected &gt; 0:&#10;            log(f&quot;内存清理完成，回收了 {collected} 个对象&quot;)&#10;            &#10;    def get_memory_usage(self):&#10;        &quot;&quot;&quot;获取当前内存使用情况&quot;&quot;&quot;&#10;        process = psutil.Process()&#10;        memory_info = process.memory_info()&#10;        return {&#10;            'rss_mb': memory_info.rss / 1024 / 1024,  # 物理内存&#10;            'vms_mb': memory_info.vms / 1024 / 1024,  # 虚拟内存&#10;            'percent': process.memory_percent()        # 内存使用百分比&#10;        }&#10;&#10;class AsyncOperationManager:&#10;    &quot;&quot;&quot;异步操作管理器 - 防止长时间操作阻塞UI&quot;&quot;&quot;&#10;    &#10;    def __init__(self, max_workers=4):&#10;        self.executor = ThreadPoolExecutor(max_workers=max_workers)&#10;        self._running_operations = {}&#10;        &#10;    def run_async(self, operation_id, func, *args, **kwargs):&#10;        &quot;&quot;&quot;异步执行操作&#10;        &#10;        Args:&#10;            operation_id: 操作唯一标识&#10;            func: 要执行的函数&#10;            *args, **kwargs: 函数参数&#10;            &#10;        Returns:&#10;            Future对象&#10;        &quot;&quot;&quot;&#10;        if operation_id in self._running_operations:&#10;            log(f&quot;操作 {operation_id} 已在运行中，跳过重复执行&quot;)&#10;            return self._running_operations[operation_id]&#10;            &#10;        future = self.executor.submit(func, *args, **kwargs)&#10;        self._running_operations[operation_id] = future&#10;        &#10;        # 操作完成后自动清理&#10;        def cleanup_operation(fut):&#10;            self._running_operations.pop(operation_id, None)&#10;            &#10;        future.add_done_callback(cleanup_operation)&#10;        return future&#10;        &#10;    def is_operation_running(self, operation_id):&#10;        &quot;&quot;&quot;检查操作是否正在运行&quot;&quot;&quot;&#10;        future = self._running_operations.get(operation_id)&#10;        return future is not None and not future.done()&#10;        &#10;    def cancel_operation(self, operation_id):&#10;        &quot;&quot;&quot;取消正在运行的操作&quot;&quot;&quot;&#10;        future = self._running_operations.get(operation_id)&#10;        if future and not future.done():&#10;            future.cancel()&#10;            return True&#10;        return False&#10;        &#10;    def shutdown(self):&#10;        &quot;&quot;&quot;关闭异步操作管理器&quot;&quot;&quot;&#10;        self.executor.shutdown(wait=True)&#10;&#10;def async_operation(operation_id=None):&#10;    &quot;&quot;&quot;异步操作装饰器 - 自动异步执行函数&quot;&quot;&quot;&#10;    def decorator(func):&#10;        @wraps(func)&#10;        def wrapper(self, *args, **kwargs):&#10;            if hasattr(self, 'async_manager'):&#10;                op_id = operation_id or f&quot;{func.__name__}_{id(self)}&quot;&#10;                return self.async_manager.run_async(op_id, func, self, *args, **kwargs)&#10;            else:&#10;                return func(self, *args, **kwargs)&#10;        return wrapper&#10;    return decorator&#10;&#10;# 标准库导入&#10;import os, sys, json, time, threading, subprocess, shutil, socket, gc&#10;import xml.etree.ElementTree as ET&#10;from datetime import datetime&#10;from functools import wraps&#10;import weakref, statistics, winreg&#10;&#10;# 第三方库导入&#10;import psutil, requests, schedule&#10;from concurrent.futures import ThreadPoolExecutor&#10;&#10;# 设置控制台编码为UTF-8，解决中文乱码问题&#10;try:&#10;    # Windows系统设置控制台编码&#10;    if sys.platform.startswith('win'):&#10;        import io&#10;        sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding='utf-8')&#10;        sys.stderr = io.TextIOWrapper(sys.stderr.buffer, encoding='utf-8')&#10;        # 设置控制台代码页为UTF-8&#10;        os.system('chcp 65001 &gt;nul 2&gt;&amp;1')&#10;except Exception as e:&#10;    pass  # 如果设置失败，继续运行&#10;try:&#10;    from PyQt5.QtWidgets import (&#10;        QApplication, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, QFormLayout,&#10;        QLineEdit, QPushButton, QCheckBox, QLabel, QGroupBox, QTabWidget, QMessageBox&#10;    )&#10;    from PyQt5.QtCore import Qt, QTimer, pyqtSignal as Signal&#10;    from PyQt5.QtGui import QIcon, QFont&#10;except ImportError as e:&#10;    print(f&quot;PyQt5导入失败: {e}&quot;)&#10;    print(&quot;请安装PyQt5: pip install PyQt5&quot;)&#10;    &#10;    # PyQt5模拟类（避免导入错误）&#10;    class MockQt:&#10;        AlignLeft = 0x0001&#10;        AlignCenter = 0x0004&#10;    &#10;    class MockSignal:&#10;        def connect(self, func): pass&#10;        def emit(self, *args): pass&#10;    &#10;    def Signal(*args): return MockSignal()&#10;    &#10;    # 批量创建模拟类&#10;    mock_classes = ['QApplication', 'QMainWindow', 'QWidget', 'QVBoxLayout', 'QHBoxLayout', &#10;                   'QFormLayout', 'QLineEdit', 'QPushButton', 'QCheckBox', 'QLabel', &#10;                   'QGroupBox', 'QTabWidget', 'QMessageBox', 'QTimer', 'QIcon', 'QFont']&#10;    &#10;    for cls_name in mock_classes:&#10;        globals()[cls_name] = type(cls_name, (), {&#10;            '__init__': lambda self, *args, **kwargs: None,&#10;            '__getattr__': lambda self, name: lambda *args, **kwargs: None&#10;        })&#10;    &#10;    Qt = MockQt()&#10;    QApplication.exec = lambda self: 0&#10;&#10;# ====================================================================&#10;# 配置管理模块&#10;# ====================================================================&#10;class ConfigManager:&#10;    &quot;&quot;&quot;配置管理器 - 统一管理配置参数，支持JSON文件持久化&quot;&quot;&quot;&#10;    &#10;    DEFAULT_CONFIG = {&#10;        # QMT相关配置&#10;        &quot;qmt_dir&quot;: r&quot;D:\DFZQxtqmt_win64&quot;,&#10;        &quot;qmt_run_time&quot;: &quot;09:28:00&quot;,&#10;        &quot;qmt_only_vip&quot;: True,&#10;        &quot;enable_qmt_shutdown&quot;: False,&#10;        &quot;qmt_shutdown_time&quot;: &quot;&quot;,&#10;        &#10;        # 彩虹客户端配置&#10;        &quot;rainbow_exe_path&quot;: r&quot;D:\quantclass\quantclass.exe&quot;,&#10;        &quot;rainbow_restart_time&quot;: &quot;09:35:00&quot;,&#10;        &quot;enable_rainbow_shutdown&quot;: False,&#10;        &quot;rainbow_shutdown_time&quot;: &quot;&quot;,&#10;        &#10;        # 数据清理配置&#10;        &quot;delete_base_path&quot;: r&quot;E:\DATA_Center\real_trading\rocket\data\系统缓存&quot;,&#10;        &quot;delete_folders&quot;: &quot;早盘数据,早盘择时&quot;,&#10;        &#10;        # 系统配置&#10;        &quot;enable_startup&quot;: True,&#10;        &quot;enable_system_shutdown&quot;: False,&#10;        &quot;system_shutdown_time&quot;: &quot;&quot;,&#10;        &quot;schedule_running&quot;: False,  # 定时任务运行状态&#10;        &#10;        # 实时监控配置&#10;        &quot;monitor_interval&quot;: 10,  # 监控间隔（秒）&#10;        &quot;notification_interval&quot;: 300,  # 通知间隔（秒，5分钟）&#10;        &quot;notification_start_time&quot;: &quot;09:00:00&quot;,  # 通知时间段开始&#10;        &quot;notification_end_time&quot;: &quot;15:30:00&quot;,   # 通知时间段结束&#10;        &#10;        # 飞书通知配置&#10;        &quot;feishu_webhook_url&quot;: &quot;&quot;,  # 飞书机器人Webhook URL&#10;        &quot;enable_feishu_notification&quot;: True,&#10;        &quot;feishu_at_all&quot;: True  # 是否@所有人，默认开启&#10;    }&#10;    &#10;    def __init__(self):&#10;        &quot;&quot;&quot;初始化配置管理器&quot;&quot;&quot;&#10;        self.config_file = os.path.join(os.path.dirname(os.path.dirname(__file__)), &quot;logs&quot;, &quot;guardian_config.json&quot;)&#10;        os.makedirs(os.path.dirname(self.config_file), exist_ok=True)&#10;        self.config = self._load_config()&#10;        log(f&quot;配置管理器已初始化，配置文件: {self.config_file}&quot;)&#10;    &#10;    def _load_config(self):&#10;        &quot;&quot;&quot;加载配置文件，不存在则使用默认配置&quot;&quot;&quot;&#10;        if os.path.exists(self.config_file):&#10;            try:&#10;                with open(self.config_file, 'r', encoding='utf-8') as f:&#10;                    loaded_config = json.load(f)&#10;                config = self.DEFAULT_CONFIG.copy()&#10;                config.update(loaded_config)&#10;                log(f&quot;成功加载配置文件: {self.config_file}&quot;)&#10;                return config&#10;            except Exception as e:&#10;                log(f&quot;加载配置文件失败: {e}，使用默认配置&quot;)&#10;                return self.DEFAULT_CONFIG.copy()&#10;        else:&#10;            log(&quot;配置文件不存在，使用默认配置&quot;)&#10;            return self.DEFAULT_CONFIG.copy()&#10;    &#10;    def save_config(self):&#10;        &quot;&quot;&quot;保存配置到JSON文件&quot;&quot;&quot;&#10;        try:&#10;            with open(self.config_file, 'w', encoding='utf-8') as f:&#10;                json.dump(self.config, f, ensure_ascii=False, indent=4)&#10;            log(f&quot;配置已保存到: {self.config_file}&quot;)&#10;            return True&#10;        except Exception as e:&#10;            log(f&quot;保存配置文件失败: {e}&quot;)&#10;            return False&#10;    &#10;    def get(self, key, default=None):&#10;        &quot;&quot;&quot;获取配置值&quot;&quot;&quot;&#10;        return self.config.get(key, default)&#10;    &#10;    def set(self, key, value):&#10;        &quot;&quot;&quot;设置配置值&quot;&quot;&quot;&#10;        self.config[key] = value&#10;        log(f&quot;配置已更新: {key} = {value}&quot;)&#10;    &#10;    def update(self, new_config):&#10;        &quot;&quot;&quot;批量更新配置&quot;&quot;&quot;&#10;        self.config.update(new_config)&#10;        log(f&quot;批量更新配置: {len(new_config)} 项&quot;)&#10;&#10;# ====================================================================&#10;# 工具函数模块&#10;# ====================================================================&#10;def log(message):&#10;    &quot;&quot;&quot;带时间戳的日志记录&quot;&quot;&quot;&#10;    timestamp = time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;)&#10;    try:&#10;        if isinstance(message, bytes):&#10;            message = message.decode('utf-8', errors='ignore')&#10;        print(f&quot;[{timestamp}] {message}&quot;, flush=True)&#10;    except Exception:&#10;        try:&#10;            safe_message = str(message).encode('ascii', errors='ignore').decode('ascii')&#10;            print(f&quot;[{timestamp}] {safe_message}&quot;, flush=True)&#10;        except:&#10;            print(f&quot;[{timestamp}] [LOG_ERROR]&quot;, flush=True)&#10;&#10;def is_valid_time(time_str):&#10;    &quot;&quot;&quot;验证时间格式，支持空值&quot;&quot;&quot;&#10;    if not time_str or time_str.strip() == &quot;&quot;:&#10;        return True&#10;    try:&#10;        time.strptime(time_str, '%H:%M:%S')&#10;        return True&#10;    except ValueError:&#10;        return False&#10;&#10;class Worker(threading.Thread):&#10;    &quot;&quot;&quot;通用工作线程 - 执行耗时操作&quot;&quot;&quot;&#10;    def __init__(self, func, *args, **kwargs):&#10;        super().__init__(daemon=True)&#10;        self.func = func&#10;        self.args = args&#10;        self.kwargs = kwargs&#10;&#10;    def run(self):&#10;        try:&#10;            self.func(*self.args, **self.kwargs)&#10;        except Exception as e:&#10;            log(f&quot;工作线程执行失败: {e}&quot;)&#10;&#10;# ====================================================================&#10;# 网络测试模块&#10;# ====================================================================&#10;class NetworkTester:&#10;    &quot;&quot;&quot;网络延迟测试工具 - 行情源优选&quot;&quot;&quot;&#10;    &#10;    @staticmethod&#10;    def measure_latency(ip, port, timeout=0.1):&#10;        &quot;&quot;&quot;测量网络延迟（毫秒）&quot;&quot;&quot;&#10;        try:&#10;            start = time.time()&#10;            with socket.create_connection((ip, int(port)), timeout=timeout):&#10;                end = time.time()&#10;                return (end - start) * 1000&#10;        except Exception:&#10;            return float('inf')&#10;    &#10;    @staticmethod&#10;    def median_latency(ip, port, count=10):&#10;        &quot;&quot;&quot;计算中位数延迟&quot;&quot;&quot;&#10;        latencies = []&#10;        for _ in range(count):&#10;            delay = NetworkTester.measure_latency(ip, port)&#10;            if delay != float('inf'):&#10;                latencies.append(delay)&#10;            time.sleep(0.05)&#10;        return statistics.median(latencies) if latencies else float('inf')&#10;&#10;# ====================================================================&#10;# 飞书通知模块&#10;# ====================================================================&#10;class FeishuNotifier:&#10;    &quot;&quot;&quot;飞书通知器 - 发送消息到群聊&quot;&quot;&quot;&#10;    &#10;    def __init__(self, webhook_url, at_all=False):&#10;        self.webhook_url = webhook_url&#10;        self.at_all = at_all&#10;        self.last_notification_time = {}&#10;        &#10;    def send_message(self, title, content, msg_type=&quot;info&quot;):&#10;        &quot;&quot;&quot;发送消息到飞书&quot;&quot;&quot;&#10;        if not self.webhook_url:&#10;            log(&quot;飞书Webhook URL未配置，跳过通知&quot;)&#10;            return False&#10;            &#10;        try:&#10;            timestamp = datetime.now().strftime(&quot;%Y-%m-%d %H:%M:%S&quot;)&#10;            color_map = {&quot;info&quot;: &quot;blue&quot;, &quot;warning&quot;: &quot;orange&quot;, &quot;error&quot;: &quot;red&quot;, &quot;success&quot;: &quot;green&quot;}&#10;            color = color_map.get(msg_type, &quot;blue&quot;)&#10;            message = {&#10;                &quot;msg_type&quot;: &quot;interactive&quot;,&#10;                &quot;card&quot;: {&#10;                    &quot;config&quot;: {&#10;                        &quot;wide_screen_mode&quot;: True&#10;                    },&#10;                    &quot;header&quot;: {&#10;                        &quot;title&quot;: {&#10;                            &quot;tag&quot;: &quot;plain_text&quot;,&#10;                            &quot;content&quot;: f&quot; {title}&quot;&#10;                        },&#10;                        &quot;template&quot;: color&#10;                    },&#10;                    &quot;elements&quot;: [&#10;                        {&#10;                            &quot;tag&quot;: &quot;div&quot;,&#10;                            &quot;text&quot;: {&#10;                                &quot;tag&quot;: &quot;plain_text&quot;,&#10;                                &quot;content&quot;: content&#10;                            }&#10;                        },&#10;                        {&#10;                            &quot;tag&quot;: &quot;div&quot;,&#10;                            &quot;text&quot;: {&#10;                                &quot;tag&quot;: &quot;plain_text&quot;,&#10;                                &quot;content&quot;: f&quot;⏰ 时间: {timestamp}&quot;&#10;                            }&#10;                        }&#10;                    ]&#10;                }&#10;            }&#10;            &#10;            if self.at_all:&#10;                message[&quot;card&quot;][&quot;elements&quot;].append({&#10;                    &quot;tag&quot;: &quot;div&quot;,&#10;                    &quot;text&quot;: {&#10;                        &quot;tag&quot;: &quot;lark_md&quot;,&#10;                        &quot;content&quot;: &quot;&lt;at user_id=\&quot;all\&quot;&gt;所有人&lt;/at&gt;&quot;&#10;                    }&#10;                })&#10;            response = requests.post(&#10;                self.webhook_url,&#10;                json=message,&#10;                timeout=10&#10;            )&#10;            &#10;            if response.status_code == 200:&#10;                result = response.json()&#10;                if result.get(&quot;code&quot;) == 0:&#10;                    log(f&quot;飞书通知发送成功: {title}&quot;)&#10;                    return True&#10;                else:&#10;                    log(f&quot;飞书通知发送失败: {result.get('msg', '未知错误')}&quot;)&#10;                    return False&#10;            else:&#10;                log(f&quot;飞书通知发送失败，HTTP状态码: {response.status_code}&quot;)&#10;                return False&#10;                &#10;        except Exception as e:&#10;            log(f&quot;发送飞书通知异常: {str(e)}&quot;)&#10;            return False&#10;    &#10;    def should_send_notification(self, notification_key, interval_seconds=300):&#10;        &quot;&quot;&quot;检查是否应该发送通知（防频繁通知）&quot;&quot;&quot;&#10;        current_time = time.time()&#10;        last_time = self.last_notification_time.get(notification_key, 0)&#10;        &#10;        if current_time - last_time &gt;= interval_seconds:&#10;            self.last_notification_time[notification_key] = current_time&#10;            return True&#10;        return False&#10;    &#10;    def is_notification_time(self, start_time=&quot;09:00:00&quot;, end_time=&quot;15:30:00&quot;):&#10;        &quot;&quot;&quot;检查当前是否在通知时间段内&quot;&quot;&quot;&#10;        try:&#10;            current_time = datetime.now().time()&#10;            start = datetime.strptime(start_time, &quot;%H:%M:%S&quot;).time()&#10;            end = datetime.strptime(end_time, &quot;%H:%M:%S&quot;).time()&#10;            return start &lt;= current_time &lt;= end&#10;        except:&#10;            return True  # 如果时间格式错误，默认允许通知&#10;&#10;# ====================================================================&#10;# 行情源优选模块（保持原有逻辑不变）&#10;# ====================================================================&#10;class ServerOptimizer:&#10;    &quot;&quot;&quot;行情源服务器优选器 - 自动选择最佳行情和交易服务器&quot;&quot;&quot;&#10;    &#10;    def __init__(self, qmt_dir_path, only_vip=True):&#10;        self.qmt_dir_path = qmt_dir_path&#10;        self.only_vip = only_vip&#10;        self.network_tester = NetworkTester()&#10;    &#10;    def find_best_servers(self):&#10;        &quot;&quot;&quot;查找最佳行情和交易服务器&quot;&quot;&quot;&#10;        log(f&quot;开始查找最佳服务器，QMT路径: {self.qmt_dir_path}&quot;)&#10;        &#10;        # 终止QMT进程&#10;        self._terminate_qmt_processes()&#10;        &#10;        # 解析配置文件&#10;        config_path = fr'{self.qmt_dir_path}\userdata_mini\users\xtquoterconfig.xml'&#10;        if not os.path.exists(config_path):&#10;            log(f&quot;错误: 配置文件不存在 {config_path}&quot;)&#10;            return None, None, None, None, None&#10;        &#10;        try:&#10;            tree = ET.parse(config_path)&#10;            quoter_server_map = tree.find('QuoterServers')&#10;            quoter_server_list = quoter_server_map.findall('QuoterServer')&#10;            &#10;            # 解析服务器信息&#10;            qs_infos = self._parse_server_info(quoter_server_list)&#10;            &#10;            # 测试服务器延迟&#10;            results = self._test_server_latency(qs_infos)&#10;            &#10;            # 选择最佳服务器&#10;            best_hq, best_jy = self._select_best_servers(results)&#10;            &#10;            return best_hq, best_jy, tree, quoter_server_map, config_path&#10;        &#10;        except Exception as e:&#10;            log(f&quot;解析配置文件出错: {str(e)}&quot;)&#10;            return None, None, None, None, None&#10;    &#10;    def _terminate_qmt_processes(self):&#10;        &quot;&quot;&quot;终止QMT进程&quot;&quot;&quot;&#10;        for proc in psutil.process_iter(['pid', 'name', 'exe']):&#10;            try:&#10;                if proc.info['name'] == 'XtMiniQmt.exe':&#10;                    exe_path = (proc.info['exe'] or '').lower()&#10;                    if self.qmt_dir_path.lower() in exe_path:&#10;                        log(f&quot;终止进程: PID={proc.pid}, Path={exe_path}&quot;)&#10;                        proc.kill()&#10;            except (psutil.NoSuchProcess, psutil.AccessDenied):&#10;                continue&#10;    &#10;    def _parse_server_info(self, quoter_server_list):&#10;        &quot;&quot;&quot;解析服务器信息&quot;&quot;&quot;&#10;        qs_infos = {}&#10;        for server in quoter_server_list:&#10;            quoter_type = server.attrib['quotertype']&#10;            if self.only_vip and quoter_type == '0' and 'VIP' not in server.attrib['servername']:&#10;                continue&#10;            info = {&#10;                'ip': server.attrib['address'],&#10;                'port': int(server.attrib['port']),&#10;                'username': server.attrib['username'],&#10;                'pwd': server.attrib['password'],&#10;                'type': quoter_type,&#10;                'servername': server.attrib['servername']&#10;            }&#10;            qs_infos[info['ip']] = info&#10;        return qs_infos&#10;    &#10;    def _test_server_latency(self, qs_infos):&#10;        &quot;&quot;&quot;测试服务器延迟&quot;&quot;&quot;&#10;        results = []&#10;        log(f&quot;开始测试 {len(qs_infos)} 个服务器...&quot;)&#10;        &#10;        for info in qs_infos.values():&#10;            median_value = self.network_tester.median_latency(info['ip'], info['port'])&#10;            info['median_value'] = median_value&#10;            results.append(info)&#10;            &#10;            server_type = &quot;行情&quot; if info['type'] == '0' else &quot;交易&quot;&#10;            log(f'{server_type}-{info[&quot;servername&quot;]} {info[&quot;ip&quot;]} 延迟: {median_value:.2f} ms')&#10;        &#10;        return results&#10;    &#10;    def _select_best_servers(self, results):&#10;        &quot;&quot;&quot;选择最佳服务器&quot;&quot;&quot;&#10;        hq_results = [r for r in results if r['type'] == '0']&#10;        jy_results = [r for r in results if r['type'] == '1']&#10;        &#10;        best_hq = min(hq_results, key=lambda x: x['median_value'], default=None)&#10;        best_jy = min(jy_results, key=lambda x: x['median_value'], default=None)&#10;        &#10;        log(&quot;=&quot; * 80)&#10;        &#10;        if best_hq:&#10;            log(f&quot;最佳行情服务器: {best_hq['servername']} IP={best_hq['ip']} 延迟: {best_hq['median_value']:.2f} ms&quot;)&#10;        else:&#10;            log(&quot;未找到有效的行情服务器&quot;)&#10;        &#10;        if best_jy:&#10;            log(f&quot;最佳交易服务器: {best_jy['servername']} IP={best_jy['ip']} 延迟: {best_jy['median_value']:.2f} ms&quot;)&#10;        else:&#10;            log(&quot;未找到有效的交易服务器&quot;)&#10;        &#10;        return best_hq, best_jy&#10;    &#10;    def update_qmt_config(self, best_hq, best_jy, tree, quoter_server_map, config_path):&#10;        &quot;&quot;&quot;更新QMT配置文件&quot;&quot;&quot;&#10;        if not best_hq or not best_jy or tree is None or quoter_server_map is None:&#10;            log(&quot;更新配置失败: 缺少必要参数&quot;)&#10;            return False&#10;        &#10;        try:&#10;            current_stock = quoter_server_map.get('current_stock')&#10;            current_trade_stock = quoter_server_map.get('current_trade_stock')&#10;            &#10;            if not current_stock or not current_trade_stock:&#10;                log(&quot;更新配置失败: 找不到当前服务器配置&quot;)&#10;                return False&#10;            &#10;            current_stock_list = current_stock.split('_')&#10;            current_stock_list[-2] = best_hq['ip']&#10;            current_stock_list[-1] = str(best_hq['port'])&#10;            &#10;            current_trade_stock_list = current_trade_stock.split('_')&#10;            current_trade_stock_list[-2] = best_jy['ip']&#10;            current_trade_stock_list[-1] = str(best_jy['port'])&#10;            &#10;            quoter_server_map.set('current_stock', '_'.join(current_stock_list))&#10;            quoter_server_map.set('current_trade_stock', '_'.join(current_trade_stock_list))&#10;            &#10;            tree.write(config_path, encoding='utf-8', xml_declaration=True)&#10;            log(f&quot;配置已更新并保存到 {config_path}&quot;)&#10;            return True&#10;        except Exception as e:&#10;            log(f&quot;更新配置文件出错: {str(e)}&quot;)&#10;            return False&#10;&#10;# ====================================================================&#10;# 进程管理模块&#10;# ====================================================================&#10;class ProcessManager:&#10;    &quot;&quot;&quot;进程管理器 - 统一管理进程启动和终止&quot;&quot;&quot;&#10;&#10;    @staticmethod&#10;    def terminate_processes_by_name(process_name, target_path=None, graceful_timeout=10):&#10;        &quot;&quot;&quot;根据进程名终止进程 - 优雅关闭机制&quot;&quot;&quot;&#10;        processes_to_kill = []&#10;&#10;        for proc in psutil.process_iter(['pid', 'name', 'exe', 'status']):&#10;            try:&#10;                if proc.info['name'] == process_name:&#10;                    if target_path is None or (proc.info['exe'] and target_path.lower() in proc.info['exe'].lower()):&#10;                        processes_to_kill.append(proc)&#10;                        log(f&quot;发现目标进程: {process_name} (PID={proc.pid}, 状态={proc.info['status']})&quot;)&#10;            except (psutil.NoSuchProcess, psutil.AccessDenied):&#10;                continue&#10;&#10;        if not processes_to_kill:&#10;            log(f&quot;未发现运行中的 {process_name} 进程&quot;)&#10;            return 0, 0&#10;&#10;        success_count = 0&#10;        failed_count = 0&#10;&#10;        for proc in processes_to_kill:&#10;            try:&#10;                if not proc.is_running():&#10;                    log(f&quot;进程 {proc.pid} 已经不存在，跳过&quot;)&#10;                    continue&#10;&#10;                log(f&quot;开始优雅关闭进程: {process_name} (PID={proc.pid})&quot;)&#10;                proc.terminate()&#10;&#10;                try:&#10;                    proc.wait(timeout=graceful_timeout)&#10;                    log(f&quot;✓ 进程 {proc.pid} 已优雅退出&quot;)&#10;                    success_count += 1&#10;                    continue&#10;                except psutil.TimeoutExpired:&#10;                    log(f&quot;⚠ 进程 {proc.pid} 在 {graceful_timeout}s 内未响应优雅关闭，强制终止&quot;)&#10;&#10;                if proc.is_running():&#10;                    proc.kill()&#10;                    try:&#10;                        proc.wait(timeout=5)&#10;                        log(f&quot;✓ 进程 {proc.pid} 已强制终止&quot;)&#10;                        success_count += 1&#10;                    except psutil.TimeoutExpired:&#10;                        log(f&quot;✗ 进程 {proc.pid} 强制终止失败，可能成为僵尸进程&quot;)&#10;                        failed_count += 1&#10;&#10;            except psutil.NoSuchProcess:&#10;                log(f&quot;✓ 进程 {proc.pid} 已自然退出&quot;)&#10;                success_count += 1&#10;            except psutil.AccessDenied:&#10;                log(f&quot;✗ 权限不足，无法终止进程 {proc.pid}&quot;)&#10;                failed_count += 1&#10;            except Exception as e:&#10;                log(f&quot;✗ 终止进程 {proc.pid} 时发生异常: {e}&quot;)&#10;                failed_count += 1&#10;&#10;        # 第三步：僵尸进程检测和清理&#10;        ProcessManager._cleanup_zombie_processes(process_name)&#10;&#10;        log(f&quot;进程终止完成: 成功 {success_count} 个，失败 {failed_count} 个&quot;)&#10;        return success_count, failed_count&#10;&#10;    @staticmethod&#10;    def _cleanup_zombie_processes(process_name):&#10;        &quot;&quot;&quot;清理僵尸进程 - 检测并报告僵尸进程状态&quot;&quot;&quot;&#10;        zombie_count = 0&#10;&#10;        try:&#10;            for proc in psutil.process_iter(['pid', 'name', 'status']):&#10;                try:&#10;                    if (proc.info['name'] == process_name and&#10;                        proc.info['status'] == psutil.STATUS_ZOMBIE):&#10;                        zombie_count += 1&#10;                        log(f&quot;⚠ 检测到僵尸进程: {process_name} (PID={proc.pid})&quot;)&#10;&#10;                        # 尝试通过父进程清理僵尸进程&#10;                        try:&#10;                            parent = proc.parent()&#10;                            if parent:&#10;                                log(f&quot;僵尸进程的父进程: PID={parent.pid}, 名称={parent.name()}&quot;)&#10;                        except (psutil.NoSuchProcess, psutil.AccessDenied):&#10;                            pass&#10;&#10;                except (psutil.NoSuchProcess, psutil.AccessDenied):&#10;                    continue&#10;        except Exception as e:&#10;            log(f&quot;僵尸进程检测时发生异常: {e}&quot;)&#10;&#10;        if zombie_count &gt; 0:&#10;            log(f&quot;⚠ 发现 {zombie_count} 个 {process_name} 僵尸进程，建议重启系统清理&quot;)&#10;        else:&#10;            log(f&quot;✓ 未发现 {process_name} 僵尸进程&quot;)&#10;&#10;    @staticmethod&#10;    def get_process_status(process_name, target_path=None):&#10;        &quot;&quot;&quot;获取进程状态信息&quot;&quot;&quot;&#10;        processes = []&#10;&#10;        for proc in psutil.process_iter(['pid', 'name', 'exe', 'status', 'create_time', 'memory_info', 'cpu_percent']):&#10;            try:&#10;                if proc.info['name'] == process_name:&#10;                    if target_path is None or (proc.info['exe'] and target_path.lower() in proc.info['exe'].lower()):&#10;                        create_time = proc.info['create_time']&#10;                        running_time = time.time() - create_time&#10;&#10;                        process_info = {&#10;                            'pid': proc.info['pid'],&#10;                            'status': proc.info['status'],&#10;                            'exe_path': proc.info['exe'],&#10;                            'running_time_seconds': running_time,&#10;                            'memory_mb': proc.info['memory_info'].rss / 1024 / 1024 if proc.info['memory_info'] else 0,&#10;                            'cpu_percent': proc.info['cpu_percent'] or 0&#10;                        }&#10;                        processes.append(process_info)&#10;&#10;            except (psutil.NoSuchProcess, psutil.AccessDenied):&#10;                continue&#10;&#10;        return {&#10;            'process_name': process_name,&#10;            'count': len(processes),&#10;            'processes': processes,&#10;            'is_running': len(processes) &gt; 0&#10;        }&#10;&#10;    @staticmethod&#10;    def start_process(exe_path, wait_for_start=True, start_timeout=30):&#10;        &quot;&quot;&quot;启动进程 - 增强版启动机制&quot;&quot;&quot;&#10;        if not os.path.exists(exe_path):&#10;            error_msg = f&quot;可执行文件不存在: {exe_path}&quot;&#10;            log(f&quot;✗ {error_msg}&quot;)&#10;            return False, error_msg&#10;&#10;        try:&#10;            log(f&quot;正在启动进程: {exe_path}&quot;)&#10;&#10;            process = subprocess.Popen([exe_path])&#10;&#10;            if not wait_for_start:&#10;                log(f&quot;✓ 进程已启动 (PID={process.pid})，未等待启动确认&quot;)&#10;                return True, process.pid&#10;&#10;            process_name = os.path.basename(exe_path)&#10;            start_time = time.time()&#10;&#10;            while time.time() - start_time &lt; start_timeout:&#10;                status = ProcessManager.get_process_status(process_name, os.path.dirname(exe_path))&#10;                if status['is_running']:&#10;                    running_process = status['processes'][0]&#10;                    log(f&quot;✓ 进程启动成功: {process_name} (PID={running_process['pid']})&quot;)&#10;                    return True, running_process['pid']&#10;&#10;                time.sleep(1)  # 每秒检查一次&#10;&#10;            # 启动超时&#10;            error_msg = f&quot;进程启动超时 ({start_timeout}s): {process_name}&quot;&#10;            log(f&quot;✗ {error_msg}&quot;)&#10;            return False, error_msg&#10;&#10;        except Exception as e:&#10;            error_msg = f&quot;启动进程时发生异常: {str(e)}&quot;&#10;            log(f&quot;✗ {error_msg}&quot;)&#10;            return False, error_msg&#10;&#10;    @staticmethod&#10;    def monitor_process_health(process_name, target_path=None):&#10;        &quot;&quot;&quot;监控进程健康状态 - 新增健康检查功能&#10;&#10;        Args:&#10;            process_name: 进程名称&#10;            target_path: 目标路径过滤（可选）&#10;&#10;        Returns:&#10;            dict: 健康状态报告&#10;        &quot;&quot;&quot;&#10;        status = ProcessManager.get_process_status(process_name, target_path)&#10;&#10;        health_report = {&#10;            'process_name': process_name,&#10;            'is_healthy': True,&#10;            'issues': [],&#10;            'recommendations': [],&#10;            'status': status&#10;        }&#10;&#10;        if not status['is_running']:&#10;            health_report['is_healthy'] = False&#10;            health_report['issues'].append(&quot;进程未运行&quot;)&#10;            health_report['recommendations'].append(&quot;检查进程是否正常启动&quot;)&#10;            return health_report&#10;&#10;        # 检查多实例问题&#10;        if status['count'] &gt; 1:&#10;            health_report['is_healthy'] = False&#10;            health_report['issues'].append(f&quot;检测到多个实例运行 ({status['count']} 个)&quot;)&#10;            health_report['recommendations'].append(&quot;终止多余的进程实例&quot;)&#10;&#10;        # 检查僵尸进程&#10;        for proc_info in status['processes']:&#10;            if proc_info['status'] == psutil.STATUS_ZOMBIE:&#10;                health_report['is_healthy'] = False&#10;                health_report['issues'].append(f&quot;检测到僵尸进程 (PID={proc_info['pid']})&quot;)&#10;                health_report['recommendations'].append(&quot;重启系统清理僵尸进程&quot;)&#10;&#10;        # 检查内存使用&#10;        for proc_info in status['processes']:&#10;            if proc_info['memory_mb'] &gt; 1000:  # 超过1GB内存&#10;                health_report['issues'].append(f&quot;内存使用较高: {proc_info['memory_mb']:.1f}MB (PID={proc_info['pid']})&quot;)&#10;                health_report['recommendations'].append(&quot;监控内存使用情况，考虑重启进程&quot;)&#10;&#10;        return health_report&#10;&#10;# ====================================================================&#10;# 实时监控模块&#10;# ====================================================================&#10;class MonitoringThread(threading.Thread):&#10;    &quot;&quot;&quot;实时监控线程 - 监控QMT进程和网络状态&quot;&quot;&quot;&#10;&#10;    def __init__(self, config_manager, feishu_notifier, status_callback=None, server_update_callback=None):&#10;        super().__init__(daemon=True)&#10;        self.config_manager = config_manager&#10;        self.feishu_notifier = feishu_notifier&#10;        self.status_callback = status_callback&#10;        self.server_update_callback = server_update_callback&#10;        self.running = False&#10;        self.last_status = {}&#10;        self.server_optimizer = None&#10;&#10;        self.last_qmt_status = False&#10;        self.last_network_status = False&#10;&#10;    def start_monitoring(self):&#10;        &quot;&quot;&quot;启动监控&quot;&quot;&quot;&#10;        self.running = True&#10;        self.start()&#10;        log(&quot;实时监控已启动&quot;)&#10;&#10;    def stop_monitoring(self):&#10;        &quot;&quot;&quot;停止监控&quot;&quot;&quot;&#10;        self.running = False&#10;        log(&quot;实时监控已停止&quot;)&#10;&#10;    def run(self):&#10;        &quot;&quot;&quot;监控主循环&quot;&quot;&quot;&#10;        while self.running:&#10;            try:&#10;                self._check_qmt_status()&#10;                self._check_network_status()&#10;&#10;                interval = self.config_manager.get('monitor_interval', 10)&#10;                time.sleep(interval)&#10;&#10;            except Exception as e:&#10;                log(f&quot;监控线程异常: {str(e)}&quot;)&#10;                time.sleep(10)&#10;&#10;    def _check_qmt_status(self):&#10;        &quot;&quot;&quot;检查QMT进程状态&quot;&quot;&quot;&#10;        qmt_dir = self.config_manager.get('qmt_dir')&#10;        if not qmt_dir:&#10;            return&#10;&#10;        qmt_running = False&#10;        qmt_processes = []&#10;        all_qmt_processes = []  # 记录所有XtMiniQmt.exe进程&#10;&#10;        for proc in psutil.process_iter(['pid', 'name', 'exe']):&#10;            try:&#10;                if proc.info['name'] == 'XtMiniQmt.exe':&#10;                    exe_path = proc.info['exe'] or ''&#10;                    all_qmt_processes.append({&#10;                        'pid': proc.info['pid'],&#10;                        'exe_path': exe_path&#10;                    })&#10;&#10;                    # 路径匹配检查 - 支持多种匹配方式&#10;                    exe_path_lower = exe_path.lower()&#10;                    qmt_dir_lower = qmt_dir.lower()&#10;&#10;                    # 方式1: 直接包含检查&#10;                    path_match_1 = qmt_dir_lower in exe_path_lower&#10;&#10;                    # 方式2: 标准化路径后检查&#10;                    try:&#10;                        exe_path_norm = os.path.normpath(exe_path_lower)&#10;                        qmt_dir_norm = os.path.normpath(qmt_dir_lower)&#10;                        path_match_2 = qmt_dir_norm in exe_path_norm&#10;                    except:&#10;                        path_match_2 = False&#10;&#10;                    # 方式3: 检查是否在QMT目录的bin.x64子目录下&#10;                    expected_exe_path = os.path.join(qmt_dir, 'bin.x64', 'XtMiniQmt.exe').lower()&#10;                    path_match_3 = exe_path_lower == expected_exe_path&#10;&#10;                    if path_match_1 or path_match_2 or path_match_3:&#10;                        qmt_running = True&#10;                        qmt_processes.append(proc.info)&#10;&#10;            except (psutil.NoSuchProcess, psutil.AccessDenied) as e:&#10;                continue&#10;&#10;        # 调试日志 - 仅在状态变化或没有找到匹配进程时输出&#10;        if not qmt_running and all_qmt_processes:&#10;            log(f&quot;[调试] 发现 {len(all_qmt_processes)} 个XtMiniQmt.exe进程，但路径不匹配:&quot;)&#10;            log(f&quot;[调试] 配置的QMT目录: {qmt_dir}&quot;)&#10;            for proc_info in all_qmt_processes:&#10;                log(f&quot;[调试] PID {proc_info['pid']}: {proc_info['exe_path']}&quot;)&#10;&#10;        current_status = {&#10;            'qmt_running': qmt_running,&#10;            'qmt_process_count': len(qmt_processes)&#10;        }&#10;&#10;        if self.last_status.get('qmt_running') != qmt_running:&#10;            self._send_qmt_status_notification(qmt_running, qmt_processes)&#10;&#10;        self.last_status.update(current_status)&#10;        # 更新QMT状态标志，用于界面显示&#10;        self.last_qmt_status = qmt_running&#10;&#10;        if self.status_callback:&#10;            status_msg = f&quot;QMT状态: {'运行中' if qmt_running else '未运行'} ({len(qmt_processes)}个进程)&quot;&#10;            self.status_callback(status_msg)&#10;&#10;    def _check_network_status(self):&#10;        &quot;&quot;&quot;检查网络连接状态&quot;&quot;&quot;&#10;        qmt_dir = self.config_manager.get('qmt_dir')&#10;        if not qmt_dir:&#10;            return&#10;&#10;        try:&#10;            if not self.server_optimizer:&#10;                only_vip = self.config_manager.get('qmt_only_vip', True)&#10;                self.server_optimizer = ServerOptimizer(qmt_dir, only_vip)&#10;&#10;            current_servers = self._get_current_server_config()&#10;            if not current_servers:&#10;                return&#10;&#10;            hq_server = current_servers.get('hq_server')&#10;            jy_server = current_servers.get('jy_server')&#10;&#10;            network_status = {&#10;                'hq_server': hq_server,&#10;                'jy_server': jy_server,&#10;                'hq_latency': float('inf'),&#10;                'jy_latency': float('inf'),&#10;                'last_test_time': datetime.now().strftime('%H:%M:%S')&#10;            }&#10;&#10;            if hq_server:&#10;                network_status['hq_latency'] = NetworkTester.measure_latency(&#10;                    hq_server['ip'], hq_server['port']&#10;                )&#10;&#10;            if jy_server:&#10;                network_status['jy_latency'] = NetworkTester.measure_latency(&#10;                    jy_server['ip'], jy_server['port']&#10;                )&#10;&#10;            # 判断网络连接状态&#10;            hq_connected = network_status['hq_latency'] != float('inf') if hq_server else True&#10;            jy_connected = network_status['jy_latency'] != float('inf') if jy_server else True&#10;            network_status['connected'] = hq_connected and jy_connected&#10;&#10;            # 更新网络状态标志，用于界面显示&#10;            self.last_network_status = network_status['connected']&#10;&#10;            self._check_network_status_change(network_status)&#10;&#10;            if self.status_callback:&#10;                status_msg = f&quot;网络状态: {'正常' if network_status.get('connected', False) else '异常'}&quot;&#10;                self.status_callback(status_msg)&#10;&#10;        except Exception as e:&#10;            log(f&quot;网络状态检查异常: {str(e)}&quot;)&#10;&#10;    def _get_current_server_config(self):&#10;        &quot;&quot;&quot;获取当前服务器配置&quot;&quot;&quot;&#10;        try:&#10;            qmt_dir = self.config_manager.get('qmt_dir')&#10;            config_path = os.path.join(qmt_dir, 'userdata_mini', 'users', 'xtquoterconfig.xml')&#10;&#10;            if not os.path.exists(config_path):&#10;                return None&#10;&#10;            tree = ET.parse(config_path)&#10;            quoter_server_map = tree.find('QuoterServers')&#10;            quoter_server_list = quoter_server_map.findall('QuoterServer')&#10;&#10;            hq_server = None&#10;            jy_server = None&#10;&#10;            for server in quoter_server_list:&#10;                server_info = {&#10;                    'ip': server.attrib['address'],&#10;                    'port': int(server.attrib['port']),&#10;                    'servername': server.attrib['servername'],&#10;                    'type': server.attrib['quotertype']&#10;                }&#10;&#10;                if server.attrib['quotertype'] == '0':  # 行情服务器&#10;                    hq_server = server_info&#10;                elif server.attrib['quotertype'] == '1':  # 交易服务器&#10;                    jy_server = server_info&#10;&#10;            return {&#10;                'hq_server': hq_server,&#10;                'jy_server': jy_server&#10;            }&#10;&#10;        except Exception as e:&#10;            log(f&quot;获取服务器配置异常: {str(e)}&quot;)&#10;            return None&#10;&#10;    def _check_network_status_change(self, network_status):&#10;        &quot;&quot;&quot;检查网络状态变化并发送通知&quot;&quot;&quot;&#10;        hq_latency = network_status.get('hq_latency', float('inf'))&#10;        jy_latency = network_status.get('jy_latency', float('inf'))&#10;&#10;        high_latency_threshold = 200&#10;&#10;        if hq_latency &gt; high_latency_threshold:&#10;            self._send_network_notification(&#10;                &quot;行情服务器延迟过高&quot;,&#10;                f&quot;当前延迟: {hq_latency:.2f}ms，建议切换服务器&quot;,&#10;                &quot;warning&quot;&#10;            )&#10;&#10;        if jy_latency &gt; high_latency_threshold:&#10;            self._send_network_notification(&#10;                &quot;交易服务器延迟过高&quot;,&#10;                f&quot;当前延迟: {jy_latency:.2f}ms，建议切换服务器&quot;,&#10;                &quot;warning&quot;&#10;            )&#10;&#10;    def _send_qmt_status_notification(self, is_running, processes):&#10;        &quot;&quot;&quot;发送QMT状态通知&quot;&quot;&quot;&#10;        if not self._should_send_notification('qmt_status'):&#10;            return&#10;&#10;        if is_running:&#10;            title = &quot;QMT启动通知&quot;&#10;            content = f&quot;QMT已启动，当前运行 {len(processes)} 个进程&quot;&#10;            msg_type = &quot;success&quot;&#10;        else:&#10;            title = &quot;QMT关闭通知&quot;&#10;            content = &quot;QMT已关闭或异常退出&quot;&#10;            msg_type = &quot;warning&quot;&#10;&#10;        self.feishu_notifier.send_message(title, content, msg_type)&#10;&#10;    def _send_network_notification(self, title, content, msg_type=&quot;info&quot;):&#10;        &quot;&quot;&quot;发送网络状态通知&quot;&quot;&quot;&#10;        if not self._should_send_notification('network_status'):&#10;            return&#10;&#10;        self.feishu_notifier.send_message(title, content, msg_type)&#10;&#10;    def _should_send_notification(self, notification_type):&#10;        &quot;&quot;&quot;检查是否应该发送通知&quot;&quot;&quot;&#10;        if not self.config_manager.get('enable_feishu_notification', True):&#10;            return False&#10;&#10;        start_time = self.config_manager.get('notification_start_time', '09:00:00')&#10;        end_time = self.config_manager.get('notification_end_time', '15:30:00')&#10;&#10;        if not self.feishu_notifier.is_notification_time(start_time, end_time):&#10;            return False&#10;&#10;        interval = self.config_manager.get('notification_interval', 300)&#10;        return self.feishu_notifier.should_send_notification(notification_type, interval)&#10;&#10;# ====================================================================&#10;# 核心业务逻辑模块&#10;# ====================================================================&#10;class CoreLogic:&#10;    &quot;&quot;&quot;核心业务逻辑控制器&quot;&quot;&quot;&#10;&#10;    def __init__(self, config_manager, status_callback, server_update_callback=None):&#10;        self.config = config_manager&#10;        self.status_callback = status_callback&#10;        self.server_update_callback = server_update_callback&#10;        &#10;        self.process_manager = ProcessManager()&#10;        self.startup_manager = StartupManager()&#10;        self.schedule_manager = ScheduleManager(config_manager, status_callback, server_update_callback)&#10;        &#10;        self.feishu_notifier = FeishuNotifier(&#10;            webhook_url=config_manager.get('feishu_webhook_url', ''),&#10;            at_all=config_manager.get('feishu_at_all', False)&#10;        )&#10;        self.monitoring_thread = None&#10;        self.start_monitoring()&#10;    &#10;    def restart_qmt(self):&#10;        &quot;&quot;&quot;立即重启QMT&quot;&quot;&quot;&#10;        self.schedule_manager.restart_qmt_service()&#10;    &#10;    def shutdown_qmt_now(self):&#10;        &quot;&quot;&quot;立即关闭QMT&quot;&quot;&quot;&#10;        self.schedule_manager.shutdown_qmt_service()&#10;    &#10;    def restart_rainbow_client(self):&#10;        &quot;&quot;&quot;立即重启彩虹客户端&quot;&quot;&quot;&#10;        self.schedule_manager.restart_rainbow_service()&#10;    &#10;    def shutdown_rainbow_now(self):&#10;        &quot;&quot;&quot;立即关闭彩虹客户端&quot;&quot;&quot;&#10;        self.schedule_manager.shutdown_rainbow_service()&#10;    &#10;    def delete_data_files_only(self):&#10;        &quot;&quot;&quot;仅删除数据文件，不重启彩虹客户端&quot;&quot;&quot;&#10;        self.schedule_manager.delete_data_files_service()&#10;    &#10;    def restart_rainbow_client_only(self):&#10;        &quot;&quot;&quot;仅重启彩虹客户端（不删除数据）&quot;&quot;&quot;&#10;        self.schedule_manager.restart_rainbow_service_only()&#10;    &#10;    def shutdown_system_now(self):&#10;        &quot;&quot;&quot;立即关机&quot;&quot;&quot;&#10;        # 创建确认对话框&#10;        msg_box = QMessageBox()&#10;        msg_box.setWindowTitle(&quot;关机确认&quot;)&#10;        msg_box.setText(&quot;确认要关闭计算机吗？&quot;)&#10;        msg_box.setInformativeText(&quot;系统将在确认后1分钟内关机。&quot;)&#10;        msg_box.setStandardButtons(QMessageBox.Yes | QMessageBox.No)&#10;        msg_box.button(QMessageBox.Yes).setText(&quot;确认&quot;)&#10;        msg_box.button(QMessageBox.No).setText(&quot;取消&quot;)&#10;        msg_box.setDefaultButton(QMessageBox.No)  # 默认选中取消按钮，避免误操作&#10;        msg_box.setIcon(QMessageBox.Warning)&#10;&#10;        # 显示对话框并获取用户选择&#10;        result = msg_box.exec_()&#10;&#10;        # 只有用户点击确认按钮才执行关机&#10;        if result == QMessageBox.Yes:&#10;            self.schedule_manager.shutdown_system_service()&#10;&#10;    def toggle_startup(self, enable):&#10;        &quot;&quot;&quot;切换开机启动状态&quot;&quot;&quot;&#10;        if self.startup_manager.set_startup(enable):&#10;            self.status_callback(&quot;已设置开机启动&quot; if enable else &quot;已取消开机启动&quot;)&#10;            return True&#10;        else:&#10;            self.status_callback(&quot;设置开机启动失败&quot;)&#10;            return False&#10;    &#10;    def check_startup_status(self):&#10;        &quot;&quot;&quot;检查开机启动状态&quot;&quot;&quot;&#10;        return self.startup_manager.check_startup_status()&#10;    &#10;    def start_schedule(self):&#10;        &quot;&quot;&quot;启动定时任务&quot;&quot;&quot;&#10;        self.schedule_manager.start_schedule()&#10;    &#10;    def stop_schedule(self):&#10;        &quot;&quot;&quot;停止定时任务&quot;&quot;&quot;&#10;        self.schedule_manager.stop_schedule()&#10;    &#10;    @property&#10;    def is_schedule_running(self):&#10;        &quot;&quot;&quot;定时任务是否正在运行&quot;&quot;&quot;&#10;        return self.schedule_manager.is_running&#10;    &#10;    def start_monitoring(self):&#10;        &quot;&quot;&quot;启动实时监控&quot;&quot;&quot;&#10;        if self.monitoring_thread and self.monitoring_thread.is_alive():&#10;            log(&quot;监控线程已在运行&quot;)&#10;            return&#10;        &#10;        self.monitoring_thread = MonitoringThread(&#10;            config_manager=self.config,&#10;            feishu_notifier=self.feishu_notifier,&#10;            status_callback=self.status_callback,&#10;            server_update_callback=self.server_update_callback&#10;        )&#10;        self.monitoring_thread.start_monitoring()&#10;        log(&quot;实时监控已启动&quot;)&#10;        self.status_callback(&quot;实时监控已启动&quot;)&#10;    &#10;    def stop_monitoring(self):&#10;        &quot;&quot;&quot;停止实时监控&quot;&quot;&quot;&#10;        if self.monitoring_thread:&#10;            self.monitoring_thread.stop_monitoring()&#10;            self.monitoring_thread = None&#10;            log(&quot;实时监控已停止&quot;)&#10;            self.status_callback(&quot;实时监控已停止&quot;)&#10;    &#10;    @property&#10;    def is_monitoring_running(self):&#10;        &quot;&quot;&quot;监控是否正在运行&quot;&quot;&quot;&#10;        return self.monitoring_thread and self.monitoring_thread.is_alive()&#10;    &#10;    def update_monitoring_config(self):&#10;        &quot;&quot;&quot;更新监控配置&quot;&quot;&quot;&#10;        if self.monitoring_thread:&#10;            # 更新飞书通知器配置&#10;            self.feishu_notifier.webhook_url = self.config.get('feishu_webhook_url', '')&#10;            self.feishu_notifier.at_all = self.config.get('feishu_at_all', False)&#10;            &#10;            # 如果监控正在运行，重启以应用新配置&#10;            if self.is_monitoring_running:&#10;                self.stop_monitoring()&#10;                self.start_monitoring()&#10;&#10;# ====================================================================&#10;# UI样式表&#10;# ====================================================================&#10;STYLESHEET = &quot;&quot;&quot;&#10;QWidget {&#10;    background-color: #1e1e1e;&#10;    color: #d4d4d4;&#10;    font-family: 'Microsoft YaHei';&#10;    font-size: 22px;&#10;}&#10;QMainWindow {&#10;    background-color: #252526;&#10;}&#10;QTabWidget::pane {&#10;    border: 1px solid #3c3c3c;&#10;    border-radius: 4px;&#10;}&#10;QTabBar::tab {&#10;    background: #2d2d2d;&#10;    color: #d4d4d4;&#10;    padding: 10px 20px;&#10;    border-top-left-radius: 4px;&#10;    border-top-right-radius: 4px;&#10;    border: 1px solid #3c3c3c;&#10;    border-bottom: none;&#10;    margin-right: 2px;&#10;}&#10;QTabBar::tab:selected {&#10;    background: #1e1e1e;&#10;    color: #ffffff;&#10;    border-bottom: 1px solid #1e1e1e;&#10;}&#10;QGroupBox {&#10;    border: 1px solid #3c3c3c;&#10;    border-radius: 5px;&#10;    margin-top: 15px;&#10;    padding-top: 20px;&#10;    font-weight: bold;&#10;}&#10;QGroupBox::title {&#10;    subcontrol-origin: margin;&#10;    subcontrol-position: top left;&#10;    padding: 0 5px;&#10;    background-color: #1e1e1e;&#10;}&#10;QLineEdit {&#10;    background-color: #3c3c3c;&#10;    border: 1px solid #555;&#10;    border-radius: 4px;&#10;    padding: 5px;&#10;    color: #d4d4d4;&#10;}&#10;QLineEdit:read-only {&#10;    background-color: #2d2d2d;&#10;}&#10;QPushButton {&#10;    background-color: #0e639c;&#10;    color: white;&#10;    border: none;&#10;    padding: 12px 15px;&#10;    border-radius: 4px;&#10;    min-height: 30px;&#10;}&#10;QPushButton:hover {&#10;    background-color: #1177bb;&#10;}&#10;QPushButton:pressed {&#10;    background-color: #0c568a;&#10;}&#10;QCheckBox {&#10;    spacing: 5px;&#10;}&#10;QCheckBox::indicator {&#10;    width: 18px;&#10;    height: 18px;&#10;}&#10;QLabel#statusLabel {&#10;    font-size: 22px;&#10;    font-weight: bold;&#10;    color: #4ec9b0;&#10;}&#10;&quot;&quot;&quot;&#10;&#10;# ====================================================================&#10;# 主窗口UI模块&#10;# ====================================================================&#10;class MainWindow(QMainWindow):&#10;    &quot;&quot;&quot;主窗口界面&quot;&quot;&quot;&#10;    status_update_signal = Signal(str)&#10;    server_update_signal = Signal(str, str)&#10;&#10;    def __init__(self):&#10;        super().__init__()&#10;        &#10;        self.config_manager = ConfigManager()&#10;        self.memory_manager = MemoryManager()&#10;        self.async_manager = AsyncOperationManager(max_workers=4)&#10;        # 先初始化 core_logic，避免 UI 构建过程中引用属性不存在&#10;        self.core_logic = CoreLogic(&#10;            self.config_manager,&#10;            self.update_status_bar,&#10;            self.update_server_info&#10;        )&#10;        self.core_logic.memory_manager = self.memory_manager&#10;        self.core_logic.async_manager = self.async_manager&#10;        &#10;        # 再初始化 UI 与其它组件&#10;        self.init_ui()&#10;        self.connect_signals()&#10;        self.init_timers()&#10;        &#10;        self.load_initial_state()&#10;&#10;    def init_ui(self):&#10;        &quot;&quot;&quot;初始化用户界面&quot;&quot;&quot;&#10;        self.setWindowTitle(&quot;∞MeowTech.实盘无限守护&quot;)&#10;        self.setGeometry(300, 300, 600, 500)&#10;        self.setStyleSheet(STYLESHEET)&#10;&#10;        self.tabs = QTabWidget()&#10;        self.setCentralWidget(self.tabs)&#10;&#10;        self.create_operation_page()&#10;        self.create_config_page()&#10;        &#10;        self.status_label = QLabel(&quot;就绪&quot;)&#10;        self.status_label.setObjectName(&quot;statusLabel&quot;)&#10;        self.statusBar().addWidget(self.status_label)&#10;&#10;    def connect_signals(self):&#10;        self.status_update_signal.connect(self.update_status_bar)&#10;        self.server_update_signal.connect(self.update_server_info)&#10;    &#10;    def init_timers(self):&#10;        self.timer = QTimer()&#10;        self.timer.timeout.connect(self.update_next_run_time)&#10;        self.timer.start(1000)&#10;    &#10;    def load_initial_state(self):&#10;        &quot;&quot;&quot;加载初始状态&quot;&quot;&quot;&#10;        if not StartupManager.diagnose_startup():&#10;            log(f&quot;✗ 开机启动诊断失败，可能存在权限或环境问题&quot;)&#10;        &#10;        config_startup = self.config_manager.get('enable_startup', False)&#10;        registry_startup = self.core_logic.check_startup_status()&#10;        &#10;        final_status = config_startup&#10;        &#10;        if config_startup != registry_startup:&#10;            log(f&quot;检测到状态不一致，开始同步&quot;)&#10;            &#10;            if self.core_logic.toggle_startup(config_startup):&#10;                new_registry_status = self.core_logic.check_startup_status()&#10;                if new_registry_status == config_startup:&#10;                    log(f&quot;✓ 同步成功&quot;)&#10;                    final_status = config_startup&#10;                else:&#10;                    final_status = registry_startup&#10;                    self.config_manager.set('enable_startup', registry_startup)&#10;                    log(f&quot;同步失败，已更新配置文件&quot;)&#10;            else:&#10;                # 同步失败，以注册表实际状态为准&#10;                final_status = registry_startup&#10;                self.config_manager.set('enable_startup', registry_startup)&#10;                log(f&quot;同步操作失败，已更新配置文件&quot;)&#10;        &#10;        # 4. 更新UI状态&#10;        self.update_button_states()&#10;        &#10;        # 5. 恢复定时任务状态&#10;        self.restore_schedule_state()&#10;        &#10;        # 6. 启动时自动重启QMT和彩虹客户端&#10;        self.perform_startup_restart()&#10;    &#10;    def restore_schedule_state(self):&#10;        &quot;&quot;&quot;恢复定时任务状态&quot;&quot;&quot;&#10;        try:&#10;            # 从配置文件读取上次的定时任务状态&#10;            was_schedule_running = self.config_manager.get('schedule_running', False)&#10;            &#10;            if was_schedule_running:&#10;                log(&quot;检测到上次定时任务处于运行状态，正在恢复...&quot;)&#10;                &#10;                # 验证配置有效性&#10;                qmt_dir = self.config_manager.get('qmt_dir')&#10;                qmt_time = self.config_manager.get('qmt_run_time')&#10;                &#10;                if os.path.exists(qmt_dir) and is_valid_time(qmt_time):&#10;                    self.core_logic.start_schedule()&#10;                    log(&quot;✓ 定时任务状态已恢复&quot;)&#10;                    # 更新UI按钮状态&#10;                    self.update_button_states()&#10;                else:&#10;                    log(&quot;✗ 配置验证失败，无法恢复定时任务状态&quot;)&#10;                    # 更新配置状态为未运行&#10;                    self.config_manager.set('schedule_running', False)&#10;                    self.config_manager.save_config()&#10;                    # 更新UI按钮状态&#10;                    self.update_button_states()&#10;            else:&#10;                log(&quot;上次定时任务未运行，保持停止状态&quot;)&#10;                &#10;        except Exception as e:&#10;            log(f&quot;恢复定时任务状态失败: {e}&quot;)&#10;            # 发生异常时确保状态为停止&#10;            self.config_manager.set('schedule_running', False)&#10;            self.config_manager.save_config()&#10;            # 更新UI按钮状态&#10;            self.update_button_states()&#10;    &#10;    def perform_startup_restart(self):&#10;        &quot;&quot;&quot;程序启动时自动重启QMT和彩虹客户端&quot;&quot;&quot;&#10;        log(&quot;程序启动检测：开始自动重启QMT和彩虹客户端...&quot;)&#10;        &#10;        def restart_worker():&#10;            try:&#10;                log(&quot;正在重启QMT...&quot;)&#10;                self.core_logic.restart_qmt()&#10;                &#10;                time.sleep(2)&#10;                &#10;                log(&quot;正在重启彩虹客户端...&quot;)&#10;                self.core_logic.restart_rainbow_client()&#10;                &#10;                log(&quot;✓ 启动时自动重启完成&quot;)&#10;                &#10;            except Exception as e:&#10;                log(f&quot;✗ 启动时自动重启失败: {e}&quot;)&#10;        &#10;        restart_thread = threading.Thread(target=restart_worker, daemon=True)&#10;        restart_thread.start()&#10;&#10;    def create_operation_page(self):&#10;        &quot;&quot;&quot;创建操作页面&quot;&quot;&quot;&#10;        page = QWidget()&#10;        layout = QVBoxLayout(page)&#10;        layout.setSpacing(20)&#10;&#10;        schedule_group = self._create_schedule_control_group()&#10;        qmt_group = self._create_qmt_control_group()&#10;        rainbow_group = self._create_rainbow_control_group()&#10;        system_group = self._create_system_control_group()&#10;        &#10;        layout.addWidget(qmt_group)&#10;        layout.addWidget(rainbow_group)&#10;        layout.addWidget(system_group)&#10;        layout.addWidget(schedule_group)&#10;        layout.addStretch()&#10;        &#10;        self.tabs.addTab(page, &quot;操作&quot;)&#10;    &#10;    def _create_qmt_control_group(self):&#10;        &quot;&quot;&quot;创建QMT控制组&quot;&quot;&quot;&#10;        qmt_group = QGroupBox(&quot;QMT 控制&quot;)&#10;        qmt_layout = QVBoxLayout()&#10;        qmt_layout.setSpacing(15)&#10;        &#10;        manual_qmt_layout = QHBoxLayout()&#10;        manual_qmt_layout.setSpacing(10)&#10;        restart_qmt_btn = QPushButton(&quot;立即重启QMT&quot;)&#10;        restart_qmt_btn.setStyleSheet(&quot;background-color: #4caf50; color: white; font-weight: bold;&quot;)&#10;        restart_qmt_btn.clicked.connect(lambda: Worker(self.core_logic.restart_qmt).start())&#10;        &#10;        shutdown_qmt_btn = QPushButton(&quot;立即关闭QMT&quot;)&#10;        shutdown_qmt_btn.clicked.connect(lambda: Worker(self.core_logic.shutdown_qmt_now).start())&#10;        &#10;        manual_qmt_layout.addWidget(restart_qmt_btn)&#10;        manual_qmt_layout.addWidget(shutdown_qmt_btn)&#10;        qmt_layout.addLayout(manual_qmt_layout)&#10;        &#10;        server_info_layout = QFormLayout()&#10;        self.best_hq_label = QLabel(&quot;待检测&quot;)&#10;        self.best_jy_label = QLabel(&quot;待检测&quot;)&#10;        server_info_layout.addRow(&quot;最佳行情服务器:&quot;, self.best_hq_label)&#10;        server_info_layout.addRow(&quot;最佳交易服务器:&quot;, self.best_jy_label)&#10;        &#10;        status_layout = QHBoxLayout()&#10;        self.network_status_label = QLabel(&quot;待检测&quot;)&#10;        self.network_status_label.setAlignment(Qt.AlignLeft)&#10;        self.qmt_process_label = QLabel(&quot;待检测&quot;)&#10;        self.qmt_process_label.setAlignment(Qt.AlignLeft)&#10;        &#10;        network_label = QLabel(&quot;网络状态:&quot;)&#10;        network_label.setAlignment(Qt.AlignLeft)&#10;        qmt_label = QLabel(&quot;  QMT进程:&quot;)&#10;        qmt_label.setAlignment(Qt.AlignLeft)&#10;        &#10;        status_layout.addWidget(network_label)&#10;        status_layout.addWidget(self.network_status_label)&#10;        status_layout.addWidget(qmt_label)&#10;        status_layout.addWidget(self.qmt_process_label)&#10;        status_layout.addStretch()&#10;        status_widget = QWidget()&#10;        status_widget.setLayout(status_layout)&#10;        server_info_layout.addRow(&quot;&quot;, status_widget)&#10;        &#10;        qmt_layout.addLayout(server_info_layout)&#10;&#10;        qmt_group.setLayout(qmt_layout)&#10;        return qmt_group&#10;    &#10;    def _create_rainbow_control_group(self):&#10;        &quot;&quot;&quot;创建彩虹客户端控制组&quot;&quot;&quot;&#10;        rainbow_group = QGroupBox(&quot;彩虹客户端控制&quot;)&#10;        rainbow_layout = QVBoxLayout()&#10;        rainbow_layout.setSpacing(10)&#10;        &#10;        # 手动操作按钮&#10;        restart_rainbow_btn = QPushButton(&quot;立即重启彩虹客户端&quot;)&#10;        restart_rainbow_btn.setStyleSheet(&quot;background-color: #4caf50; color: white; font-weight: bold;&quot;)&#10;        restart_rainbow_btn.clicked.connect(lambda: Worker(self.core_logic.restart_rainbow_client_only).start())&#10;        rainbow_layout.addWidget(restart_rainbow_btn)&#10;        &#10;        shutdown_rainbow_btn = QPushButton(&quot;立即关闭彩虹客户端&quot;)&#10;        shutdown_rainbow_btn.clicked.connect(lambda: Worker(self.core_logic.shutdown_rainbow_now).start())&#10;        rainbow_layout.addWidget(shutdown_rainbow_btn)&#10;        &#10;        # 新增：独立的删除数据文件按钮&#10;        delete_data_btn = QPushButton(&quot;删除数据文件&quot;)&#10;        delete_data_btn.clicked.connect(lambda: Worker(self.core_logic.delete_data_files_only).start())&#10;        rainbow_layout.addWidget(delete_data_btn)&#10;        &#10;        rainbow_group.setLayout(rainbow_layout)&#10;        return rainbow_group&#10;    &#10;    def _create_schedule_control_group(self):&#10;        &quot;&quot;&quot;创建定时任务总控&quot;&quot;&quot;&#10;        group = QGroupBox(&quot;定时任务总控&quot;)&#10;        layout = QVBoxLayout()&#10;        layout.setSpacing(15)&#10;&#10;        self.schedule_btn = QPushButton(&quot;启动总定时器&quot;)&#10;        self.schedule_btn.setCheckable(True)&#10;        self.schedule_btn.clicked.connect(self.toggle_schedule)&#10;&#10;        self.next_run_label = QLabel(&quot;下次运行时间:\n定时任务未启动&quot;)&#10;        self.next_run_label.setAlignment(Qt.AlignLeft)&#10;        self.next_run_label.setStyleSheet(&quot;font-size: 24px; color: #4ec9b0; font-weight: bold;&quot;)&#10;&#10;        layout.addWidget(self.schedule_btn)&#10;        layout.addWidget(self.next_run_label)&#10;&#10;        group.setLayout(layout)&#10;        return group&#10;&#10;    def _create_system_control_group(self):&#10;        &quot;&quot;&quot;创建系统控制组&quot;&quot;&quot;&#10;        system_group = QGroupBox(&quot;系统控制&quot;)&#10;        system_layout = QVBoxLayout()&#10;        system_layout.setSpacing(10)&#10;        &#10;        self.startup_btn = QPushButton(&quot;设置开机启动&quot;)&#10;        self.startup_btn.clicked.connect(self.toggle_startup)&#10;        system_layout.addWidget(self.startup_btn)&#10;&#10;        shutdown_system_btn = QPushButton(&quot;立即关机&quot;)&#10;        # 修复: 不能在后台线程中创建/执行 QMessageBox，否则会导致窗口卡死“未响应”&#10;        # 原实现: shutdown_system_btn.clicked.connect(lambda: Worker(self.core_logic.shutdown_system_now).start())&#10;        shutdown_system_btn.clicked.connect(self.core_logic.shutdown_system_now)&#10;        system_layout.addWidget(shutdown_system_btn)&#10;&#10;        system_group.setLayout(system_layout)&#10;        return system_group&#10;    &#10;&#10;&#10;    def create_config_page(self):&#10;        &quot;&quot;&quot;创建配置页面&quot;&quot;&quot;&#10;        page = QWidget()&#10;        layout = QVBoxLayout(page)&#10;&#10;        qmt_group = self._create_qmt_config_group()&#10;        rainbow_group = self._create_rainbow_config_group()&#10;        delete_group = self._create_delete_config_group()&#10;        system_monitoring_group = self._create_system_monitoring_config_group()&#10;        &#10;        button_layout = QHBoxLayout()&#10;        &#10;        button_layout.addStretch()&#10;        &#10;        save_btn = QPushButton(&quot;保存配置&quot;)&#10;        save_btn.clicked.connect(self.save_config)&#10;        button_layout.addWidget(save_btn)&#10;&#10;        layout.addWidget(qmt_group)&#10;        layout.addWidget(rainbow_group)&#10;        layout.addWidget(delete_group)&#10;        layout.addWidget(system_monitoring_group)&#10;        layout.addLayout(button_layout)&#10;        layout.addStretch()&#10;        &#10;        self.tabs.addTab(page, &quot;配置&quot;)&#10;    &#10;    def _create_qmt_config_group(self):&#10;        &quot;&quot;&quot;创建QMT配置组&quot;&quot;&quot;&#10;        qmt_group = QGroupBox(&quot;QMT 配置&quot;)&#10;        qmt_form = QFormLayout()&#10;        &#10;        self.qmt_dir_input = QLineEdit(self.config_manager.get('qmt_dir'))&#10;        self.qmt_run_time_input = QLineEdit(self.config_manager.get('qmt_run_time'))&#10;        self.qmt_run_time_input.setPlaceholderText(&quot;留空则不执行&quot;)&#10;        self.qmt_shutdown_time_edit = QLineEdit(self.config_manager.get('qmt_shutdown_time', '15:05:00'))&#10;        self.qmt_shutdown_time_edit.setPlaceholderText(&quot;留空则不执行&quot;)&#10;        self.qmt_only_vip_checkbox = QCheckBox(&quot;仅使用VIP服务器&quot;)&#10;        self.qmt_only_vip_checkbox.setChecked(self.config_manager.get(&quot;qmt_only_vip&quot;, True))&#10;        &#10;        # 创建定时时间范围的水平布局&#10;        qmt_time_widget = QWidget()&#10;        qmt_time_layout = QHBoxLayout(qmt_time_widget)&#10;        qmt_time_layout.setContentsMargins(0, 0, 0, 0)&#10;        qmt_time_layout.addWidget(self.qmt_run_time_input)&#10;        qmt_time_layout.addWidget(QLabel(&quot; / &quot;))&#10;        qmt_time_layout.addWidget(self.qmt_shutdown_time_edit)&#10;        &#10;        qmt_form.addRow(&quot;QMT 路径:&quot;, self.qmt_dir_input)&#10;        qmt_form.addRow(&quot;定时 重启/关闭:&quot;, qmt_time_widget)&#10;        qmt_form.addRow(&quot;&quot;, self.qmt_only_vip_checkbox)&#10;        &#10;        qmt_group.setLayout(qmt_form)&#10;        return qmt_group&#10;    &#10;    def _create_rainbow_config_group(self):&#10;        &quot;&quot;&quot;创建彩虹客户端配置组&quot;&quot;&quot;&#10;        rainbow_group = QGroupBox(&quot;彩虹客户端配置&quot;)&#10;        rainbow_form = QFormLayout()&#10;        &#10;        self.rainbow_exe_path_input = QLineEdit(self.config_manager.get('rainbow_exe_path'))&#10;        self.rainbow_restart_time_input = QLineEdit(self.config_manager.get('rainbow_restart_time'))&#10;        self.rainbow_restart_time_input.setPlaceholderText(&quot;留空则不执行&quot;)&#10;        self.rainbow_shutdown_time_edit = QLineEdit(self.config_manager.get('rainbow_shutdown_time', '15:10:00'))&#10;        self.rainbow_shutdown_time_edit.setPlaceholderText(&quot;留空则不执行&quot;)&#10;        &#10;        rainbow_time_widget = QWidget()&#10;        rainbow_time_layout = QHBoxLayout(rainbow_time_widget)&#10;        rainbow_time_layout.setContentsMargins(0, 0, 0, 0)&#10;        rainbow_time_layout.addWidget(self.rainbow_restart_time_input)&#10;        rainbow_time_layout.addWidget(QLabel(&quot; / &quot;))&#10;        rainbow_time_layout.addWidget(self.rainbow_shutdown_time_edit)&#10;        &#10;        rainbow_form.addRow(&quot;彩虹客户端路径:&quot;, self.rainbow_exe_path_input)&#10;        rainbow_form.addRow(&quot;定时 重启/关闭:&quot;, rainbow_time_widget)&#10;        &#10;        rainbow_group.setLayout(rainbow_form)&#10;        return rainbow_group&#10;    &#10;    def _create_delete_config_group(self):&#10;        &quot;&quot;&quot;创建数据删除配置组&quot;&quot;&quot;&#10;        delete_group = QGroupBox(&quot;数据删除配置&quot;)&#10;        delete_form = QFormLayout()&#10;        &#10;        self.delete_base_path_input = QLineEdit(self.config_manager.get('delete_base_path'))&#10;        self.delete_folders_input = QLineEdit(self.config_manager.get('delete_folders'))&#10;        &#10;        delete_form.addRow(&quot;基础路径:&quot;, self.delete_base_path_input)&#10;        delete_form.addRow(&quot;文件夹名称 (逗号分隔):&quot;, self.delete_folders_input)&#10;        &#10;        delete_group.setLayout(delete_form)&#10;        return delete_group&#10;    &#10;    def _create_system_monitoring_config_group(self):&#10;        &quot;&quot;&quot;创建系统监控配置组&quot;&quot;&quot;&#10;        system_monitoring_group = QGroupBox(&quot;系统监控配置&quot;)&#10;        system_monitoring_form = QFormLayout()&#10;        &#10;        # 定时关机配置&#10;        self.system_shutdown_time_edit = QLineEdit(self.config_manager.get('system_shutdown_time', '15:30:00'))&#10;        self.system_shutdown_time_edit.setPlaceholderText(&quot;留空则不执行&quot;)&#10;        system_monitoring_form.addRow(&quot;定时关机:&quot;, self.system_shutdown_time_edit)&#10;        &#10;        # 监控间隔配置&#10;        self.monitor_interval_input = QLineEdit(str(self.config_manager.get('monitor_interval', 10)))&#10;        self.monitor_interval_input.setPlaceholderText(&quot;监控间隔（秒）&quot;)&#10;        self.notification_interval_input = QLineEdit(str(self.config_manager.get('notification_interval', 300)))&#10;        self.notification_interval_input.setPlaceholderText(&quot;通知间隔（秒）&quot;)&#10;        &#10;        interval_widget = QWidget()&#10;        interval_layout = QHBoxLayout(interval_widget)&#10;        interval_layout.setContentsMargins(0, 0, 0, 0)&#10;        interval_layout.addWidget(self.monitor_interval_input)&#10;        interval_layout.addWidget(QLabel(&quot; / &quot;))&#10;        interval_layout.addWidget(self.notification_interval_input)&#10;        &#10;        system_monitoring_form.addRow(&quot;监控/通知 间隔(秒):&quot;, interval_widget)&#10;        &#10;        # 通知时间范围配置&#10;        self.notification_start_time_input = QLineEdit(self.config_manager.get('notification_start_time', '09:00:00'))&#10;        self.notification_start_time_input.setPlaceholderText(&quot;HH:MM:SS&quot;)&#10;        self.notification_end_time_input = QLineEdit(self.config_manager.get('notification_end_time', '15:30:00'))&#10;        self.notification_end_time_input.setPlaceholderText(&quot;HH:MM:SS&quot;)&#10;        &#10;        time_range_widget = QWidget()&#10;        time_range_layout = QHBoxLayout(time_range_widget)&#10;        time_range_layout.setContentsMargins(0, 0, 0, 0)&#10;        time_range_layout.addWidget(self.notification_start_time_input)&#10;        time_range_layout.addWidget(QLabel(&quot; - &quot;))&#10;        time_range_layout.addWidget(self.notification_end_time_input)&#10;        &#10;        system_monitoring_form.addRow(&quot;通知时间范围:&quot;, time_range_widget)&#10;        &#10;        # 飞书通知配置&#10;        self.feishu_webhook_input = QLineEdit(self.config_manager.get('feishu_webhook_url', ''))&#10;        self.feishu_webhook_input.setPlaceholderText(&quot;飞书机器人Webhook URL（配置即开启通知，默认@所有人）&quot;)&#10;        # 设置更长的输入框最小宽度&#10;        self.feishu_webhook_input.setMinimumWidth(400)&#10;        &#10;        system_monitoring_form.addRow(&quot;飞书Webhook:&quot;, self.feishu_webhook_input)&#10;        &#10;        system_monitoring_group.setLayout(system_monitoring_form)&#10;        return system_monitoring_group&#10;    def toggle_schedule(self):&#10;        &quot;&quot;&quot;切换定时任务状态&quot;&quot;&quot;&#10;        if self.core_logic.is_schedule_running:&#10;            self.core_logic.stop_schedule()&#10;            # 保存定时任务停止状态&#10;            self.config_manager.set('schedule_running', False)&#10;            self.config_manager.save_config()&#10;        else:&#10;            qmt_dir = self.config_manager.get('qmt_dir')&#10;            qmt_time = self.config_manager.get('qmt_run_time')&#10;            &#10;            if not os.path.exists(qmt_dir):&#10;                QMessageBox.warning(self, &quot;错误&quot;, &quot;QMT 路径不存在，请检查配置&quot;)&#10;                return&#10;            &#10;            if not is_valid_time(qmt_time):&#10;                QMessageBox.warning(self, &quot;错误&quot;, &quot;QMT 定时重启时间格式不正确&quot;)&#10;                return&#10;            &#10;            self.core_logic.start_schedule()&#10;            # 保存定时任务启动状态&#10;            self.config_manager.set('schedule_running', True)&#10;            self.config_manager.save_config()&#10;        &#10;        self.update_button_states()&#10;    &#10;    def toggle_monitoring(self):&#10;        &quot;&quot;&quot;切换监控状态&quot;&quot;&quot;&#10;        if self.core_logic.is_monitoring_running:&#10;            self.core_logic.stop_monitoring()&#10;        else:&#10;            self.core_logic.start_monitoring()&#10;    &#10;&#10;    &#10;    def toggle_startup(self):&#10;        &quot;&quot;&quot;切换开机启动状态&quot;&quot;&quot;&#10;        current_status = self.config_manager.get('enable_startup', False)&#10;        target_status = not current_status&#10;        &#10;        if not StartupManager.diagnose_startup():&#10;            QMessageBox.warning(self, &quot;警告&quot;, &#10;                              &quot;开机启动环境检查失败，可能存在权限问题。\n&quot;&#10;                              &quot;请尝试以管理员身份运行程序。&quot;)&#10;            return&#10;        &#10;        if self.core_logic.toggle_startup(target_status):&#10;            actual_status = self.core_logic.check_startup_status()&#10;            &#10;            if actual_status == target_status:&#10;                self.config_manager.set('enable_startup', target_status)&#10;                self.update_button_states()&#10;                &#10;                success_msg = &quot;✓ 开机启动已启用&quot; if target_status else &quot;✓ 开机启动已禁用&quot;&#10;                log(f&quot;{success_msg}&quot;)&#10;                QMessageBox.information(self, &quot;成功&quot;, success_msg)&#10;            else:&#10;                error_msg = f&quot;设置操作完成，但验证失败\n期望状态: {target_status}\n实际状态: {actual_status}&quot;&#10;                log(f&quot;✗ {error_msg}&quot;)&#10;                QMessageBox.warning(self, &quot;警告&quot;, error_msg)&#10;                &#10;                # 以实际状态为准更新配置&#10;                self.config_manager.set('enable_startup', actual_status)&#10;                self.update_button_states()&#10;        else:&#10;            # 操作失败&#10;            error_msg = f&quot;{'启用' if target_status else '禁用'}开机启动失败\n请检查系统权限或重试&quot;&#10;            log(f&quot;✗ {error_msg}&quot;)&#10;            QMessageBox.critical(self, &quot;错误&quot;, error_msg)&#10;&#10;    # ----------------------------------------------------------------&#10;    # 配置管理&#10;    def save_config(self):&#10;        &quot;&quot;&quot;保存配置&quot;&quot;&quot;&#10;        qmt_time = self.qmt_run_time_input.text().strip()&#10;        qmt_shutdown_time = self.qmt_shutdown_time_edit.text().strip()&#10;        rainbow_time = self.rainbow_restart_time_input.text().strip()&#10;        rainbow_shutdown_time = self.rainbow_shutdown_time_edit.text().strip()&#10;        system_shutdown_time = self.system_shutdown_time_edit.text().strip()&#10;        &#10;        if not is_valid_time(qmt_time):&#10;            QMessageBox.warning(self, &quot;错误&quot;, &quot;QMT定时重启时间格式不正确，请使用 HH:MM:SS 格式或留空不启用&quot;)&#10;            return&#10;        &#10;        if not is_valid_time(qmt_shutdown_time):&#10;            QMessageBox.warning(self, &quot;错误&quot;, &quot;QMT定时关闭时间格式不正确，请使用 HH:MM:SS 格式或留空不执行&quot;)&#10;            return&#10;        &#10;        if not is_valid_time(rainbow_time):&#10;            QMessageBox.warning(self, &quot;错误&quot;, &quot;彩虹客户端定时重启时间格式不正确，请使用 HH:MM:SS 格式或留空不启用&quot;)&#10;            return&#10;        &#10;        if not is_valid_time(rainbow_shutdown_time):&#10;            QMessageBox.warning(self, &quot;错误&quot;, &quot;彩虹客户端定时关闭时间格式不正确，请使用 HH:MM:SS 格式或留空不执行&quot;)&#10;            return&#10;        &#10;        if not is_valid_time(system_shutdown_time):&#10;            QMessageBox.warning(self, &quot;错误&quot;, &quot;系统定时关机时间格式不正确，请使用 HH:MM:SS 格式或留空不执行&quot;)&#10;            return&#10;        &#10;        monitor_interval = self.monitor_interval_input.text().strip()&#10;        notification_interval = self.notification_interval_input.text().strip()&#10;        notification_start_time = self.notification_start_time_input.text().strip()&#10;        notification_end_time = self.notification_end_time_input.text().strip()&#10;        &#10;        try:&#10;            if monitor_interval:&#10;                int(monitor_interval)&#10;            if notification_interval:&#10;                int(notification_interval)&#10;        except ValueError:&#10;            QMessageBox.warning(self, &quot;错误&quot;, &quot;监控间隔和通知间隔必须是数字&quot;)&#10;            return&#10;        &#10;        if not is_valid_time(notification_start_time):&#10;            QMessageBox.warning(self, &quot;错误&quot;, &quot;通知开始时间格式不正确，请使用 HH:MM:SS 格式&quot;)&#10;            return&#10;        &#10;        if not is_valid_time(notification_end_time):&#10;            QMessageBox.warning(self, &quot;错误&quot;, &quot;通知结束时间格式不正确，请使用 HH:MM:SS 格式&quot;)&#10;            return&#10;        &#10;        config_updates = {&#10;            'qmt_dir': self.qmt_dir_input.text().strip(),&#10;            'qmt_run_time': qmt_time,&#10;            'qmt_shutdown_time': qmt_shutdown_time,&#10;            'qmt_only_vip': self.qmt_only_vip_checkbox.isChecked(),&#10;            'rainbow_exe_path': self.rainbow_exe_path_input.text().strip(),&#10;            'rainbow_restart_time': rainbow_time,&#10;            'rainbow_shutdown_time': rainbow_shutdown_time,&#10;            'delete_base_path': self.delete_base_path_input.text().strip(),&#10;            'delete_folders': self.delete_folders_input.text().strip(),&#10;            'system_shutdown_time': system_shutdown_time,&#10;            'monitor_interval': int(monitor_interval) if monitor_interval else 10,&#10;            'notification_interval': int(notification_interval) if notification_interval else 300,&#10;            'notification_start_time': notification_start_time,&#10;            'notification_end_time': notification_end_time,&#10;            'enable_feishu_notification': bool(self.feishu_webhook_input.text().strip()),&#10;            'feishu_webhook_url': self.feishu_webhook_input.text().strip(),&#10;            'feishu_at_all': True&#10;        }&#10;        &#10;        self.config_manager.update(config_updates)&#10;        &#10;        if self.config_manager.save_config():&#10;            self.update_status_bar(&quot;配置已保存！&quot;)&#10;            &#10;            # 自动测试飞书通知&#10;            feishu_url = self.feishu_webhook_input.text().strip()&#10;            if feishu_url:&#10;                try:&#10;                    test_notifier = FeishuNotifier(&#10;                        webhook_url=feishu_url,&#10;                        at_all=self.config_manager.get('feishu_at_all', False)&#10;                    )&#10;                    &#10;                    success = test_notifier.send_message(&#10;                        title=&quot; 配置保存测试通知&quot;,&#10;                        content=&quot;配置已成功保存，这是一条来自∞MeowTech.实盘无限守护的测试通知&quot;,&#10;                        msg_type=&quot;info&quot;&#10;                    )&#10;                    &#10;                    if success:&#10;                        QMessageBox.information(self, &quot;成功&quot;, &quot;配置已成功保存！\n飞书通知测试成功！&quot;)&#10;                        self.update_status_bar(&quot;配置已保存，飞书通知测试成功&quot;)&#10;                    else:&#10;                        QMessageBox.warning(self, &quot;部分成功&quot;, &quot;配置已成功保存！\n但飞书通知测试失败，请检查Webhook URL&quot;)&#10;                        self.update_status_bar(&quot;配置已保存，飞书通知测试失败&quot;)&#10;                        &#10;                except Exception as e:&#10;                    QMessageBox.warning(self, &quot;部分成功&quot;, f&quot;配置已成功保存！\n但飞书通知测试时发生错误: {str(e)}&quot;)&#10;                    self.update_status_bar(f&quot;配置已保存，飞书通知测试错误: {str(e)}&quot;)&#10;            else:&#10;                QMessageBox.information(self, &quot;成功&quot;, &quot;配置已成功保存！&quot;)&#10;        else:&#10;            QMessageBox.warning(self, &quot;错误&quot;, &quot;配置保存失败！&quot;)&#10;        &#10;        if self.core_logic.is_schedule_running:&#10;            self.core_logic.stop_schedule()&#10;            self.core_logic.start_schedule()&#10;        &#10;        self.core_logic.update_monitoring_config()&#10;        &#10;        self.update_button_states()&#10;    &#10;    def closeEvent(self, event):&#10;        &quot;&quot;&quot;关闭窗口前保存配置并清理资源&quot;&quot;&quot;&#10;        try:&#10;            self.config_manager.save_config()&#10;            &#10;            if hasattr(self, 'async_manager'):&#10;                self.async_manager.shutdown()&#10;                &#10;            # 强制清理内存&#10;            if hasattr(self, 'memory_manager'):&#10;                self.memory_manager.force_cleanup()&#10;                &#10;            log(&quot;程序资源清理完成&quot;)&#10;        except Exception as e:&#10;            log(f&quot;资源清理时发生错误: {e}&quot;)&#10;        finally:&#10;            super().closeEvent(event)&#10;&#10;    def update_button_states(self):&#10;        &quot;&quot;&quot;更新按钮状态和文本&quot;&quot;&quot;&#10;        if self.core_logic.is_schedule_running:&#10;            self.schedule_btn.setText(&quot;停止定时任务&quot;)&#10;            self.schedule_btn.setStyleSheet(&quot;background-color: #f44336; color: white;&quot;)&#10;        else:&#10;            self.schedule_btn.setText(&quot;启动定时任务&quot;)&#10;            self.schedule_btn.setStyleSheet(&quot;background-color: #4caf50; color: white;&quot;)&#10;        &#10;        if self.config_manager.get('enable_startup', False):&#10;            self.startup_btn.setText(&quot;取消开机启动&quot;)&#10;            self.startup_btn.setStyleSheet(&quot;background-color: #ff9800; color: white;&quot;)&#10;        else:&#10;            self.startup_btn.setText(&quot;设置开机启动&quot;)&#10;            self.startup_btn.setStyleSheet(&quot;background-color: #2196f3; color: white;&quot;)&#10;&#10;&#10;    &#10;    def update_next_run_time(self):&#10;        &quot;&quot;&quot;更新下次运行时间显示并监控内存使用情况&quot;&quot;&quot;&#10;        if hasattr(self, 'memory_manager'):&#10;            self.memory_manager.cleanup_if_needed()&#10;            &#10;        if self.core_logic.is_schedule_running:&#10;            next_run = schedule.next_run()&#10;            if next_run:&#10;                restart_tasks = []&#10;                shutdown_tasks = []&#10;                system_tasks = []&#10;                &#10;                qmt_time = self.config_manager.get('qmt_run_time')&#10;                if qmt_time:&#10;                    restart_tasks.append(f&quot;QMT重启: {qmt_time}&quot;)&#10;                &#10;                rainbow_time = self.config_manager.get('rainbow_restart_time')&#10;                if rainbow_time:&#10;                    restart_tasks.append(f&quot;彩虹重启: {rainbow_time}&quot;)&#10;                &#10;                qmt_shutdown_time = self.config_manager.get('qmt_shutdown_time')&#10;                if qmt_shutdown_time:&#10;                    shutdown_tasks.append(f&quot;QMT关闭: {qmt_shutdown_time}&quot;)&#10;                &#10;                rainbow_shutdown_time = self.config_manager.get('rainbow_shutdown_time')&#10;                if rainbow_shutdown_time:&#10;                    shutdown_tasks.append(f&quot;彩虹关闭: {rainbow_shutdown_time}&quot;)&#10;                &#10;                system_shutdown_time = self.config_manager.get('system_shutdown_time')&#10;                if system_shutdown_time:&#10;                    system_tasks.append(f&quot;系统关机: {system_shutdown_time}&quot;)&#10;                &#10;                status_lines = [&quot;下次运行时间:&quot;]&#10;                if restart_tasks:&#10;                    status_lines.append(&quot;重启任务: &quot; + &quot; / &quot;.join(restart_tasks))&#10;                if shutdown_tasks:&#10;                    status_lines.append(&quot;关闭任务: &quot; + &quot; / &quot;.join(shutdown_tasks))&#10;                if system_tasks:&#10;                    status_lines.append(&quot;系统任务: &quot; + &quot; / &quot;.join(system_tasks))&#10;                &#10;                if len(status_lines) &gt; 1:&#10;                    status = &quot;\n&quot;.join(status_lines)&#10;                else:&#10;                    status = &quot;下次运行时间:\n无有效任务配置&quot;&#10;            else:&#10;                status = &quot;下次运行时间: 计算中...&quot;&#10;        else:&#10;            status = &quot;下次运行时间: 定时任务未启动&quot;&#10;        &#10;        self.next_run_label.setText(status)&#10;        &#10;        self.update_monitoring_status()&#10;    &#10;    def update_status_bar(self, message):&#10;        &quot;&quot;&quot;线程安全地更新状态栏文本&quot;&quot;&quot;&#10;        if threading.current_thread() is not threading.main_thread():&#10;            self.status_update_signal.emit(message)&#10;        else:&#10;            log(message)&#10;            self.status_label.setText(message)&#10;    &#10;    def update_server_info(self, hq_info, jy_info):&#10;        &quot;&quot;&quot;更新服务器信息显示&quot;&quot;&quot;&#10;        if threading.current_thread() is not threading.main_thread():&#10;            self.server_update_signal.emit(hq_info, jy_info)&#10;        else:&#10;            self.best_hq_label.setText(hq_info)&#10;            self.best_jy_label.setText(jy_info)&#10;    &#10;    def update_monitoring_status(self):&#10;        &quot;&quot;&quot;更新监控状态显示并检查内存使用情况&quot;&quot;&quot;&#10;        try:&#10;            if hasattr(self, 'memory_manager'):&#10;                self.memory_manager.cleanup_if_needed()&#10;                &#10;            if hasattr(self, 'network_status_label') and hasattr(self, 'qmt_process_label'):&#10;                is_running = self.core_logic.is_monitoring_running&#10;                if is_running and hasattr(self.core_logic, 'monitoring_thread') and self.core_logic.monitoring_thread:&#10;                    network_status = &quot;正常&quot; if self.core_logic.monitoring_thread.last_network_status else &quot;异常&quot;&#10;                    qmt_status = &quot;运行中&quot; if self.core_logic.monitoring_thread.last_qmt_status else &quot;未运行&quot;&#10;                    &#10;                    # 内存显示已移除&#10;                    &#10;                    self.network_status_label.setText(network_status)&#10;                    self.qmt_process_label.setText(qmt_status)&#10;                    &#10;                    network_color = &quot;#51cf66&quot; if self.core_logic.monitoring_thread.last_network_status else &quot;#ff6b6b&quot;&#10;                    qmt_color = &quot;#51cf66&quot; if self.core_logic.monitoring_thread.last_qmt_status else &quot;#ff6b6b&quot;&#10;                    &#10;                    self.network_status_label.setStyleSheet(f&quot;color: {network_color}; font-weight: bold; font-size: 14px;&quot;)&#10;                    self.qmt_process_label.setStyleSheet(f&quot;color: {qmt_color}; font-weight: bold; font-size: 14px;&quot;)&#10;                else:&#10;                    self.network_status_label.setText(&quot;待检测&quot;)&#10;                    self.qmt_process_label.setText(&quot;待检测&quot;)&#10;                    self.network_status_label.setStyleSheet(&quot;color: #868e96; font-size: 14px;&quot;)&#10;                    self.qmt_process_label.setStyleSheet(&quot;color: #868e96; font-size: 14px;&quot;)&#10;        except Exception as e:&#10;            log(f&quot;更新监控状态显示时发生错误: {e}&quot;)&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>